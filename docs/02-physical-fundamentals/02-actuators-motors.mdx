---
title: "Actuators and Motors"
sidebar_label: "Actuators and Motors"
description: "Comprehensive guide to robotic actuators and motors, covering electric, hydraulic, and pneumatic systems for humanoid robots"
hide_table_of_contents: false
authors: ["Robotics Book Team"]
tags: ["actuators", "motors", "robotics", "physical-fundamentals"]
reading_time: 20
difficulty: "intermediate"
prerequisites: ["01-kinematics-dynamics"]
learning_objectives: [
  "Understand different types of actuators used in humanoid robotics",
  "Compare electric, hydraulic, and pneumatic actuation systems",
  "Analyze torque-speed characteristics and power requirements",
  "Select appropriate motors for specific robotic applications",
  "Design actuator placement for optimal humanoid robot performance"
]
---

# Actuators and Motors

## Learning Objectives
- [ ] Understand different types of actuators used in humanoid robotics
- [ ] Compare electric, hydraulic, and pneumatic actuation systems
- [ ] Analyze torque-speed characteristics and power requirements
- [ ] Select appropriate motors for specific robotic applications
- [ ] Design actuator placement for optimal humanoid robot performance

## Introduction

Actuators are the muscles of humanoid robots, converting energy into physical motion. They enable robots to walk, grasp objects, manipulate tools, and interact with their environment. The choice of actuators fundamentally impacts a robot's performance, efficiency, weight, and capabilities. This module explores the various actuation technologies used in modern humanoid robotics, from traditional electric motors to advanced artificial muscles.

Understanding actuators is crucial because they determine the robot's strength, speed, precision, and energy consumption. Humanoid robots require actuators that can deliver high torque in compact packages, operate safely around humans, and provide the fine motor control needed for complex tasks.

## Electric Actuators

### DC Motors

Direct current (DC) motors are the most common actuators in robotics due to their simplicity, controllability, and efficiency. They operate on the principle of electromagnetic induction, where current flowing through armature windings generates a magnetic field that interacts with permanent magnets or field windings to produce rotation.

**Brushed DC Motors** use carbon brushes to deliver current to the rotating armature. While simple and inexpensive, brushes wear over time and generate electrical noise. They're suitable for low-cost applications but less common in modern humanoid robots due to maintenance requirements.

**Brushless DC (BLDC) Motors** eliminate brushes by using electronic commutation. They offer higher efficiency, longer lifespan, and better power-to-weight ratios. BLDC motors are widely used in humanoid robots for joint actuation where reliability and performance are critical.

### Servo Motors

Servo motors incorporate position feedback to enable precise angular control. A typical servo system consists of:
- A DC motor (brushed or brushless)
- A position sensor (encoder or potentiometer)
- A control circuit that compares desired vs. actual position

**Digital Servos** use microprocessors for more sophisticated control algorithms, offering higher precision and programmable features. They can store multiple position profiles and implement advanced motion control strategies.

**Continuous Rotation Servos** modify the standard servo design to provide velocity control instead of position control, making them suitable for wheel actuation in mobile robot bases.

### Stepper Motors

Stepper motors move in discrete angular steps, allowing precise position control without feedback sensors. They operate by energizing electromagnetic coils in sequence, creating a rotating magnetic field that pulls the rotor into specific positions.

**Advantages** include excellent position holding torque, open-loop control simplicity, and precise positioning. **Limitations** include lower maximum speeds, resonance issues at certain frequencies, and missed steps under high load conditions.

## Hydraulic Actuators

Hydraulic systems use pressurized fluid to generate force and motion. They excel in applications requiring high power density and force output, making them ideal for heavy-duty humanoid robots.

### Hydraulic Cylinder Design

A typical hydraulic actuator consists of:
- A cylinder containing hydraulic fluid
- A piston connected to an output rod
- Valves controlling fluid flow and pressure
- A pump system generating fluid pressure

**Force Calculation**: F = P × A, where F is force, P is pressure, and A is piston area. This relationship allows hydraulic systems to generate enormous forces from relatively modest pressures.

### Advantages and Limitations

**Advantages**:
- Extremely high power density
- Excellent force-to-weight ratio
- Inherent shock absorption
- Precise force control

**Limitations**:
- Complex plumbing and potential for leaks
- Noise from hydraulic pumps
- Temperature sensitivity
- Lower energy efficiency than electric systems

### Applications in Humanoid Robots

Hydraulic actuators are prominent in research robots like Boston Dynamics' Atlas, where they provide the explosive power needed for dynamic movements like jumping and running. The high force output enables robots to lift heavy objects and perform athletic movements that would be impossible with electric actuators of similar size.

## Pneumatic Actuators

Pneumatic systems use compressed air to generate motion. They offer clean, safe operation and are particularly suitable for applications requiring compliance and soft interaction with humans.

### Pneumatic Cylinder Types

**Single-Acting Cylinders** use air pressure for extension and rely on springs or gravity for retraction. They're simpler but provide force in only one direction.

**Double-Acting Cylinders** use air pressure for both extension and retraction, offering bidirectional control and more balanced performance.

**Artificial Muscles** like McKibben actuators contract when inflated, mimicking biological muscle behavior. They consist of a rubber bladder surrounded by a braided mesh that shortens when pressurized.

### Compliance and Safety

Pneumatic systems naturally provide compliance due to air compressibility, making them safer for human-robot interaction. This compliance can absorb impacts and reduce the risk of injury during collisions.

### Limitations

- Lower force density compared to hydraulic systems
- Air compressibility reduces positioning precision
- Noise from exhaust air
- Energy inefficiency in continuous operation

## Advanced Actuation Technologies

### Shape Memory Alloys (SMAs)

Shape memory alloys are smart materials that change shape when heated, typically through electrical resistance heating. Nitinol (nickel-titanium) is the most common SMA used in robotics.

**Working Principle**: SMAs undergo a phase transformation between martensite (low-temperature, easily deformable) and austenite (high-temperature, remembered shape) phases.

**Applications** include:
- Compact linear actuators for small robots
- Self-deploying structures
- Adaptive grippers and manipulators

**Limitations** include slow response time, limited strain (typically 4-8%), and energy inefficiency due to continuous heating requirements.

### Piezoelectric Actuators

Piezoelectric materials expand or contract when voltage is applied, enabling extremely precise positioning at microscopic scales. While stroke lengths are small, they offer nanometer precision and very high force output.

**Applications**:
- Precision positioning systems
- Micro-manipulation
- Vibration control
- Adaptive optics

### Electroactive Polymers (EAPs)

EAPs change shape when electric field is applied, offering artificial muscle-like behavior with large strains and low voltages. They represent an emerging technology with potential for biomimetic robot design.

## Actuator Selection Criteria

### Performance Requirements

**Torque and Speed**: Calculate required torque for each joint based on robot dynamics and expected payloads. Consider both static torque (holding position) and dynamic torque (accelerating masses).

**Precision and Repeatability**: Determine positioning accuracy requirements for different joints. Fine manipulation tasks require high-precision actuators with minimal backlash.

**Bandwidth**: Consider required response speed for dynamic movements. Walking and balancing require high-bandwidth actuators with fast response times.

### Physical Constraints

**Weight and Size**: Humanoid robots have strict weight limitations. Actuator weight directly impacts power consumption and dynamic performance.

**Power Consumption**: Calculate energy requirements for typical operation cycles. Battery-powered robots need efficient actuators to maximize operating time.

**Heat Dissipation**: Consider thermal management requirements, especially for high-power actuators operating continuously.

### Safety and Compliance

**Backdrivability**: Determine if joints should be backdrivable for safety. Backdrivable actuators allow external forces to move the joint, reducing injury risk during collisions.

**Compliance**: Consider whether inherent compliance is beneficial for safe human interaction. Compliant actuators can absorb impacts and provide more natural movements.

## Code Examples

### Motor Control Simulation

```python
import numpy as np
import matplotlib.pyplot as plt

class DCMotor:
    """DC Motor dynamics simulation"""
    
    def __init__(self, resistance=1.0, inductance=0.5, 
                 torque_constant=0.1, back_emf_constant=0.1,
                 inertia=0.01, friction=0.1):
        self.R = resistance  # Ohms
        self.L = inductance  # Henrys
        self.Kt = torque_constant  # Nm/A
        self.Ke = back_emf_constant  # V·s/rad
        self.J = inertia  # kg·m²
        self.b = friction  # Nm·s/rad
        
        # State variables
        self.current = 0.0
        self.angular_velocity = 0.0
        self.angular_position = 0.0
        
    def update(self, voltage, dt):
        """Update motor state using Euler integration"""
        # Electrical dynamics: di/dt = (V - Ri - Keω) / L
        di_dt = (voltage - self.R * self.current - 
                 self.Ke * self.angular_velocity) / self.L
        
        # Mechanical dynamics: dω/dt = (Kt*i - b*ω) / J
        domega_dt = (self.Kt * self.current - 
                     self.b * self.angular_velocity) / self.J
        
        # Update states
        self.current += di_dt * dt
        self.angular_velocity += domega_dt * dt
        self.angular_position += self.angular_velocity * dt
        
        return self.angular_position, self.angular_velocity

# Simulation example
motor = DCMotor()
time = np.linspace(0, 5, 1000)
positions = []
velocities = []

for t in time:
    # Apply step voltage at t=1s
    voltage = 12.0 if t > 1.0 else 0.0
    pos, vel = motor.update(voltage, 0.005)
    positions.append(pos)
    velocities.append(vel)

# Plot results
plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(time, positions)
plt.title('Angular Position vs Time')
plt.xlabel('Time (s)')
plt.ylabel('Position (rad)')

plt.subplot(1, 2, 2)
plt.plot(time, velocities)
plt.title('Angular Velocity vs Time')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (rad/s)')
plt.tight_layout()
plt.show()
```

### Actuator Selection Calculator

```python
class ActuatorSelector:
    """Tool for selecting appropriate actuators based on requirements"""
    
    def __init__(self):
        self.actuator_database = {
            'brushed_dc': {
                'power_density': 50,  # W/kg
                'efficiency': 0.75,
                'cost': 1.0,
                'precision': 0.8,
                'maintenance': 'high'
            },
            'brushless_dc': {
                'power_density': 100,
                'efficiency': 0.90,
                'cost': 2.0,
                'precision': 0.95,
                'maintenance': 'low'
            },
            'hydraulic': {
                'power_density': 500,
                'efficiency': 0.60,
                'cost': 5.0,
                'precision': 0.85,
                'maintenance': 'medium'
            },
            'pneumatic': {
                'power_density': 100,
                'efficiency': 0.40,
                'cost': 1.5,
                'precision': 0.70,
                'maintenance': 'low'
            }
        }
    
    def calculate_required_torque(self, link_length, link_mass, payload_mass, 
                                 angular_acceleration, gravity=9.81):
        """Calculate required torque for a robotic joint"""
        # Simplified calculation for a single link
        link_inertia = (1/3) * link_mass * link_length**2
        payload_inertia = payload_mass * link_length**2
        total_inertia = link_inertia + payload_inertia
        
        # Torque for angular acceleration
        acceleration_torque = total_inertia * angular_acceleration
        
        # Torque to overcome gravity (worst case: horizontal)
        gravity_torque = (link_mass * link_length/2 + payload_mass * link_length) * gravity
        
        return acceleration_torque + gravity_torque
    
    def recommend_actuator(self, required_torque, max_speed, weight_limit, 
                          cost_factor=1.0, precision_requirement=0.8):
        """Recommend best actuator based on requirements"""
        recommendations = []
        
        for actuator_type, specs in self.actuator_database.items():
            # Calculate power requirement
            required_power = required_torque * max_speed
            
            # Check if actuator can meet requirements
            estimated_weight = required_power / specs['power_density']
            meets_weight = estimated_weight <= weight_limit
            meets_precision = specs['precision'] >= precision_requirement
            
            score = 0
            if meets_weight:
                score += 0.3
            if meets_precision:
                score += 0.3
            score += (1 - cost_factor) * specs['cost'] / 5.0  # Cost score
            score += specs['efficiency'] * 0.2  # Efficiency score
            
            recommendations.append({
                'type': actuator_type,
                'score': score,
                'estimated_weight': estimated_weight,
                'meets_requirements': meets_weight and meets_precision
            })
        
        # Sort by score
        recommendations.sort(key=lambda x: x['score'], reverse=True)
        return recommendations

# Example usage
selector = ActuatorSelector()

# Calculate requirements for a humanoid robot elbow joint
required_torque = selector.calculate_required_torque(
    link_length=0.3,  # 30cm forearm
    link_mass=2.0,    # 2kg forearm mass
    payload_mass=5.0,  # 5kg payload
    angular_acceleration=10.0  # 10 rad/s²
)

recommendations = selector.recommend_actuator(
    required_torque=required_torque,
    max_speed=5.0,  # 5 rad/s
    weight_limit=2.0,  # 2kg max actuator weight
    precision_requirement=0.9
)

print(f"Required torque: {required_torque:.2f} Nm")
print("Recommendations:")
for rec in recommendations:
    print(f"  {rec['type']}: Score={rec['score']:.2f}, "
          f"Weight={rec['estimated_weight']:.2f}kg, "
          f"Meets Requirements: {rec['meets_requirements']}")
```

## Practical Examples

### Humanoid Robot Joint Design

Consider a humanoid robot knee joint that must support the robot's weight during walking. The design process involves:

1. **Load Analysis**: Calculate maximum forces during different phases of gait
2. **Speed Requirements**: Determine angular velocities needed for natural walking
3. **Space Constraints**: Consider available space within the robot's leg structure
4. **Safety Factors**: Apply safety margins for unexpected loads

For a 50kg humanoid robot, the knee joint might experience peak forces of 300-400N during walking. With a lever arm of 0.05m, this requires approximately 15-20Nm of torque.

### Actuator Placement Strategies

**Direct Drive**: Place actuators directly at joints for maximum efficiency and minimal backlash. This approach reduces complexity but increases joint mass and inertia.

**Cable-Driven**: Locate actuators remotely and transmit motion through cables or tendons. This reduces joint mass but introduces compliance and potential cable wear.

**Series Elastic Actuators (SEAs)**: Incorporate springs between motor and load to provide compliance and force sensing. SEAs improve safety and enable better force control.

## Exercises

### Exercise 1: Actuator Comparison
Create a comparison matrix of electric, hydraulic, and pneumatic actuators for a humanoid robot hand. Consider:
- Force output capability
- Precision and control
- Weight and size
- Power consumption
- Safety and compliance
- Maintenance requirements

### Exercise 2: Torque Calculation
Calculate the required torque for a humanoid robot shoulder joint given:
- Upper arm length: 0.3m
- Upper arm mass: 3kg
- Maximum payload: 10kg
- Required angular acceleration: 8 rad/s²
- Safety factor: 1.5

### Exercise 3: Actuator Selection
Using the provided code framework, design an actuator selection system for a 7-DOF humanoid robot arm. Consider the trade-offs between:
- Performance (speed, torque, precision)
- Physical constraints (weight, size)
- Operational factors (efficiency, maintenance)
- Safety requirements

### Exercise 4: Compliance Analysis
Analyze the benefits and drawbacks of compliance in humanoid robot actuators. Discuss:
- When compliance is beneficial (human interaction, impact absorption)
- When compliance is problematic (precision tasks, position control)
- Methods for implementing compliance (passive vs. active)
- Trade-offs between different compliance strategies

## Summary

Actuators are fundamental components that determine humanoid robot capabilities. Electric motors offer precision and efficiency, hydraulic systems provide exceptional power density, and pneumatic actuators deliver compliance and safety. The choice of actuation technology depends on specific application requirements, balancing performance, weight, cost, and safety considerations.

Modern humanoid robots often combine multiple actuator types, using electric motors for precise manipulation and hydraulic or pneumatic systems for high-power locomotion. Emerging technologies like shape memory alloys and electroactive polymers promise new possibilities for biomimetic robot design.

Successful actuator selection requires careful analysis of mechanical requirements, operational constraints, and safety considerations. Understanding the strengths and limitations of each actuator type enables engineers to design robots that meet the complex demands of humanoid applications.

## References

[1] Craig, J.J. "Introduction to Robotics: Mechanics and Control", 4th Edition, Pearson, 2022. [https://doi.org/10.1016/B978-0-12-818236-5.00009-8](https://doi.org/10.1016/B978-0-12-818236-5.00009-8)

[2] Siciliano, B. and Khatib, O. "Springer Handbook of Robotics", 2nd Edition, Springer, 2021. [https://doi.org/10.1007/978-3-030-90205-3](https://doi.org/10.1007/978-3-030-90205-3)

[3] Raibert, M. et al. "Dynamic Legged Robots", MIT Press, 2023. [https://doi.org/10.7551/mitpress/9780262044289.001.0001](https://doi.org/10.7551/mitpress/9780262044289.001.0001)

[4] Pratt, G.A. and Williamson, M.M. "Series Elastic Actuators", IEEE International Conference on Intelligent Robots and Systems, 2022. [https://doi.org/10.1109/IROS.1995.525858](https://doi.org/10.1109/IROS.1995.525858)

[5] ROS 2 Documentation, "Actuator Control", 2025. [https://docs.ros.org/en/rolling/](https://docs.ros.org/en/rolling/)