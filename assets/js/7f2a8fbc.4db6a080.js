"use strict";(globalThis.webpackChunkphysical_and_humanoid_robotics_book=globalThis.webpackChunkphysical_and_humanoid_robotics_book||[]).push([[256],{4158:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"physical-fundamentals/control-theory","title":"Control Theory and Systems","description":"Comprehensive guide to control theory for humanoid robots, covering classical control, modern control, and advanced control strategies","source":"@site/docs/02-physical-fundamentals/05-control-theory.mdx","sourceDirName":"02-physical-fundamentals","slug":"/physical-fundamentals/control-theory","permalink":"/Robotics-Book/docs/physical-fundamentals/control-theory","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02-physical-fundamentals/05-control-theory.mdx","tags":[{"inline":true,"label":"control-theory","permalink":"/Robotics-Book/docs/tags/control-theory"},{"inline":true,"label":"robotics","permalink":"/Robotics-Book/docs/tags/robotics"},{"inline":true,"label":"feedback-systems","permalink":"/Robotics-Book/docs/tags/feedback-systems"},{"inline":true,"label":"physical-fundamentals","permalink":"/Robotics-Book/docs/tags/physical-fundamentals"}],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Control Theory and Systems","sidebar_label":"Control Theory and Systems","description":"Comprehensive guide to control theory for humanoid robots, covering classical control, modern control, and advanced control strategies","hide_table_of_contents":false,"authors":["Robotics Book Team"],"tags":["control-theory","robotics","feedback-systems","physical-fundamentals"],"reading_time":28,"difficulty":"advanced","prerequisites":["01-kinematics-dynamics","02-actuators-motors","03-sensors"],"learning_objectives":["Understand fundamental control theory concepts for robotics","Design and implement PID controllers for robot joints","Apply state-space methods for multi-variable control","Implement adaptive and robust control strategies","Analyze control system stability and performance"]},"sidebar":"bookSidebar","previous":{"title":"Power Systems and Energy Management","permalink":"/Robotics-Book/docs/physical-fundamentals/power-systems"},"next":{"title":"Anthropomorphic Design Principles","permalink":"/Robotics-Book/docs/humanoid-design/anthropomorphic-design"}}');var i=t(4848),s=t(8453);const r={title:"Control Theory and Systems",sidebar_label:"Control Theory and Systems",description:"Comprehensive guide to control theory for humanoid robots, covering classical control, modern control, and advanced control strategies",hide_table_of_contents:!1,authors:["Robotics Book Team"],tags:["control-theory","robotics","feedback-systems","physical-fundamentals"],reading_time:28,difficulty:"advanced",prerequisites:["01-kinematics-dynamics","02-actuators-motors","03-sensors"],learning_objectives:["Understand fundamental control theory concepts for robotics","Design and implement PID controllers for robot joints","Apply state-space methods for multi-variable control","Implement adaptive and robust control strategies","Analyze control system stability and performance"]},a="Control Theory and Systems",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Classical Control Theory",id:"classical-control-theory",level:2},{value:"Feedback Control Principles",id:"feedback-control-principles",level:3},{value:"PID Control",id:"pid-control",level:3},{value:"Frequency Domain Analysis",id:"frequency-domain-analysis",level:3},{value:"State-Space Control",id:"state-space-control",level:2},{value:"State-Space Representation",id:"state-space-representation",level:3},{value:"Optimal Control",id:"optimal-control",level:3},{value:"Advanced Control Strategies",id:"advanced-control-strategies",level:2},{value:"Adaptive Control",id:"adaptive-control",level:3},{value:"Robust Control",id:"robust-control",level:3},{value:"Nonlinear Control",id:"nonlinear-control",level:3},{value:"Control System Analysis",id:"control-system-analysis",level:2},{value:"Stability Analysis",id:"stability-analysis",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Balance Control",id:"balance-control",level:3},{value:"Impedance Control",id:"impedance-control",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: PID Controller Tuning",id:"exercise-1-pid-controller-tuning",level:3},{value:"Exercise 2: State-Space Controller Design",id:"exercise-2-state-space-controller-design",level:3},{value:"Exercise 3: Adaptive Control Implementation",id:"exercise-3-adaptive-control-implementation",level:3},{value:"Exercise 4: Balance Control Design",id:"exercise-4-balance-control-design",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function p(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"control-theory-and-systems",children:"Control Theory and Systems"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand fundamental control theory concepts for robotics"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Design and implement PID controllers for robot joints"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply state-space methods for multi-variable control"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement adaptive and robust control strategies"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Analyze control system stability and performance"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Control theory provides the mathematical foundation for making robots move precisely and reliably. While actuators provide the physical power to move robot joints, control systems determine how those joints move in response to commands and disturbances. For humanoid robots, control systems must coordinate dozens of joints simultaneously, handle complex dynamics, maintain balance, and adapt to changing conditions."}),"\n",(0,i.jsx)(e.p,{children:"This module explores control theory from classical PID control to modern adaptive and robust control methods. We'll examine how these theories apply specifically to humanoid robots, where the challenges include high degrees of freedom, nonlinear dynamics, unstable equilibrium points, and the need for safe human-robot interaction."}),"\n",(0,i.jsx)(e.h2,{id:"classical-control-theory",children:"Classical Control Theory"}),"\n",(0,i.jsx)(e.h3,{id:"feedback-control-principles",children:"Feedback Control Principles"}),"\n",(0,i.jsx)(e.p,{children:"Feedback control continuously measures system output and adjusts inputs to achieve desired behavior. The basic components include:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Reference Input"}),": Desired state or trajectory\n",(0,i.jsx)(e.strong,{children:"Controller"}),": Computes control signals based on error\n",(0,i.jsx)(e.strong,{children:"Actuator"}),": Converts control signals to physical action\n",(0,i.jsx)(e.strong,{children:"Plant"}),": The system being controlled (robot dynamics)\n",(0,i.jsx)(e.strong,{children:"Sensor"}),": Measures actual system state\n",(0,i.jsx)(e.strong,{children:"Comparator"}),": Calculates error between desired and actual states"]}),"\n",(0,i.jsx)(e.h3,{id:"pid-control",children:"PID Control"}),"\n",(0,i.jsx)(e.p,{children:"Proportional-Integral-Derivative (PID) control is the most widely used control strategy in robotics due to its simplicity and effectiveness."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Proportional Control (P)"}),": Control output is proportional to current error"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Provides immediate response to errors"}),"\n",(0,i.jsx)(e.li,{children:"Higher gain reduces steady-state error but can cause oscillations"}),"\n",(0,i.jsx)(e.li,{children:"Cannot eliminate steady-state error for constant disturbances"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Integral Control (I)"}),": Control output integrates past errors"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Eliminates steady-state error"}),"\n",(0,i.jsx)(e.li,{children:"Can cause overshoot and slow response"}),"\n",(0,i.jsx)(e.li,{children:"Windup occurs when error persists for long periods"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Derivative Control (D)"}),": Control output predicts future error based on rate of change"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Provides damping and improves stability"}),"\n",(0,i.jsx)(e.li,{children:"Reduces overshoot and settling time"}),"\n",(0,i.jsx)(e.li,{children:"Amplifies noise in sensor measurements"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nclass PIDController:\n    \"\"\"PID controller implementation for robotic systems\"\"\"\n    \n    def __init__(self, kp=1.0, ki=0.0, kd=0.0, output_limits=None, \n                 integral_limits=None, sample_time=0.01):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n        \n        self.output_limits = output_limits  # (min, max)\n        self.integral_limits = integral_limits  # (min, max)\n        self.sample_time = sample_time\n        \n        # Internal state\n        self.integral = 0.0\n        self.previous_error = 0.0\n        self.previous_time = None\n        \n    def update(self, setpoint, measured_value, current_time=None):\n        \"\"\"Update PID controller and return control output\"\"\"\n        # Calculate error\n        error = setpoint - measured_value\n        \n        # Handle time\n        if current_time is None:\n            current_time = self.previous_time + self.sample_time if self.previous_time else 0.0\n        \n        if self.previous_time is not None:\n            dt = current_time - self.previous_time\n        else:\n            dt = self.sample_time\n        \n        # Proportional term\n        p_term = self.kp * error\n        \n        # Integral term\n        self.integral += error * dt\n        \n        # Anti-windup\n        if self.integral_limits:\n            self.integral = np.clip(self.integral, \n                                  self.integral_limits[0], \n                                  self.integral_limits[1])\n        \n        i_term = self.ki * self.integral\n        \n        # Derivative term\n        if dt > 0:\n            derivative = (error - self.previous_error) / dt\n        else:\n            derivative = 0.0\n        \n        d_term = self.kd * derivative\n        \n        # Calculate total output\n        output = p_term + i_term + d_term\n        \n        # Apply output limits\n        if self.output_limits:\n            output = np.clip(output, self.output_limits[0], self.output_limits[1])\n        \n        # Update state\n        self.previous_error = error\n        self.previous_time = current_time\n        \n        return output\n    \n    def reset(self):\n        \"\"\"Reset controller state\"\"\"\n        self.integral = 0.0\n        self.previous_error = 0.0\n        self.previous_time = None\n\nclass JointController:\n    \"\"\"Multi-joint controller for humanoid robots\"\"\"\n    \n    def __init__(self, joint_names, pid_params):\n        self.controllers = {}\n        self.joint_names = joint_names\n        \n        for joint in joint_names:\n            params = pid_params.get(joint, {'kp': 10.0, 'ki': 0.1, 'kd': 1.0})\n            self.controllers[joint] = PIDController(**params)\n    \n    def control_step(self, setpoints, measured_positions, current_time=None):\n        \"\"\"Compute control outputs for all joints\"\"\"\n        control_outputs = {}\n        \n        for joint in self.joint_names:\n            setpoint = setpoints.get(joint, 0.0)\n            measured = measured_positions.get(joint, 0.0)\n            \n            control_output = self.controllers[joint].update(\n                setpoint, measured, current_time\n            )\n            control_outputs[joint] = control_output\n        \n        return control_outputs\n    \n    def reset_all(self):\n        \"\"\"Reset all joint controllers\"\"\"\n        for controller in self.controllers.values():\n            controller.reset()\n\n# Example: PID controller tuning and simulation\ndef simulate_pid_system(kp, ki, kd, simulation_time=10.0):\n    \"\"\"Simulate PID-controlled system response\"\"\"\n    # System model: G(s) = 1/(s^2 + 2s + 1) (second-order system)\n    dt = 0.01\n    time_steps = int(simulation_time / dt)\n    \n    # Initialize controller and system\n    controller = PIDController(kp=kp, ki=ki, kd=kd, sample_time=dt)\n    \n    # System state [position, velocity]\n    state = np.array([0.0, 0.0])\n    \n    # Storage for results\n    time_history = []\n    position_history = []\n    setpoint_history = []\n    control_history = []\n    \n    # Setpoint (step input)\n    setpoint = 1.0\n    \n    for i in range(time_steps):\n        current_time = i * dt\n        \n        # Get control output\n        control_signal = controller.update(setpoint, state[0], current_time)\n        \n        # System dynamics (Euler integration)\n        # d\xb2x/dt\xb2 + 2dx/dt + x = u\n        acceleration = control_signal - 2 * state[1] - state[0]\n        state[1] += acceleration * dt  # velocity\n        state[0] += state[1] * dt      # position\n        \n        # Store results\n        time_history.append(current_time)\n        position_history.append(state[0])\n        setpoint_history.append(setpoint)\n        control_history.append(control_signal)\n    \n    return time_history, position_history, setpoint_history, control_history\n\n# Test different PID parameters\npid_configs = [\n    {'kp': 5.0, 'ki': 0.0, 'kd': 0.0, 'label': 'P only'},\n    {'kp': 5.0, 'ki': 1.0, 'kd': 0.0, 'label': 'PI'},\n    {'kp': 5.0, 'ki': 0.5, 'kd': 2.0, 'label': 'PID'},\n    {'kp': 10.0, 'ki': 1.0, 'kd': 3.0, 'label': 'PID (tuned)'}\n]\n\nplt.figure(figsize=(15, 10))\n\nfor i, config in enumerate(pid_configs):\n    time, position, setpoint, control = simulate_pid_system(\n        config['kp'], config['ki'], config['kd']\n    )\n    \n    plt.subplot(2, 2, i+1)\n    plt.plot(time, position, 'b-', label='Actual')\n    plt.plot(time, setpoint, 'r--', label='Setpoint')\n    plt.title(f\"PID Response: {config['label']}\")\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position')\n    plt.legend()\n    plt.grid(True)\n\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"frequency-domain-analysis",children:"Frequency Domain Analysis"}),"\n",(0,i.jsx)(e.p,{children:"Frequency domain analysis helps understand control system behavior across different frequencies:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Transfer Functions"}),": Mathematical representation of system dynamics in frequency domain\n",(0,i.jsx)(e.strong,{children:"Bode Plots"}),": Show magnitude and phase response across frequencies\n",(0,i.jsx)(e.strong,{children:"Nyquist Plots"}),": Assess stability using frequency response\n",(0,i.jsx)(e.strong,{children:"Gain and Phase Margins"}),": Measure stability robustness"]}),"\n",(0,i.jsx)(e.h2,{id:"state-space-control",children:"State-Space Control"}),"\n",(0,i.jsx)(e.h3,{id:"state-space-representation",children:"State-Space Representation"}),"\n",(0,i.jsx)(e.p,{children:"State-space methods provide a unified framework for analyzing and controlling complex systems with multiple inputs and outputs."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"State Vector"}),": x(t) - contains all system variables needed to describe system state\n",(0,i.jsx)(e.strong,{children:"Input Vector"}),": u(t) - control inputs to the system\n",(0,i.jsx)(e.strong,{children:"Output Vector"}),": y(t) - measurable outputs\n",(0,i.jsx)(e.strong,{children:"State Equation"}),": \u1e8b = Ax + Bu - describes system dynamics\n",(0,i.jsx)(e.strong,{children:"Output Equation"}),": y = Cx + Du - relates state to outputs"]}),"\n",(0,i.jsx)(e.p,{children:"For a humanoid robot joint:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"State: [position, velocity]"}),"\n",(0,i.jsx)(e.li,{children:"Input: motor torque"}),"\n",(0,i.jsx)(e.li,{children:"Output: position (and optionally velocity)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class StateSpaceSystem:\n    """State-space system representation and control"""\n    \n    def __init__(self, A, B, C, D):\n        self.A = np.array(A)  # State matrix\n        self.B = np.array(B)  # Input matrix\n        self.C = np.array(C)  # Output matrix\n        self.D = np.array(D)  # Feedthrough matrix\n        \n        self.state = np.zeros(A.shape[0])\n        \n    def update(self, input_signal, dt):\n        """Update system state using Euler integration"""\n        # State equation: \u1e8b = Ax + Bu\n        state_derivative = self.A @ self.state + self.B @ input_signal\n        \n        # Integrate\n        self.state += state_derivative * dt\n        \n        # Output equation: y = Cx + Du\n        output = self.C @ self.state + self.D @ input_signal\n        \n        return output\n    \n    def reset(self):\n        """Reset system state to zero"""\n        self.state = np.zeros(self.A.shape[0])\n\nclass StateSpaceController:\n    """State-space controller design methods"""\n    \n    @staticmethod\n    def pole_placement(A, B, desired_poles):\n        """Design state feedback controller using pole placement"""\n        from scipy import signal\n        \n        # Check controllability\n        n = A.shape[0]\n        controllability_matrix = np.hstack([np.linalg.matrix_power(A @ B, i) \n                                          for i in range(n)])\n        \n        if np.linalg.matrix_rank(controllability_matrix) < n:\n            raise ValueError("System is not controllable")\n        \n        # Place poles using Ackermann\'s formula or similar\n        # For simplicity, using scipy\'s pole placement\n        K, _ = signal.place_poles(A, B, desired_poles)\n        \n        return K.gain_matrix\n    \n    @staticmethod\n    def lqr_design(A, B, Q, R):\n        """Design Linear Quadratic Regulator (LQR) controller"""\n        from scipy import linalg\n        \n        # Solve algebraic Riccati equation\n        P = linalg.solve_continuous_are(A, B, Q, R)\n        \n        # Calculate optimal gain\n        K = np.linalg.inv(R) @ B.T @ P\n        \n        return K, P\n    \n    @staticmethod\n    def observer_design(A, C, desired_poles):\n        """Design state observer (Luenberger observer)"""\n        # Observer form: \u1e8b\u0302 = A\u1e8b\u0302 + Bu + L(y - \u0177)\n        # where \u0177 = C\u1e8b\u0302\n        \n        # Transpose system for pole placement\n        A_T = A.T\n        C_T = C.T\n        \n        # Design observer gain using pole placement\n        from scipy import signal\n        L_T, _ = signal.place_poles(A_T, C_T, desired_poles)\n        L = L_T.gain_matrix.T\n        \n        return L\n\nclass RobotJointModel:\n    """State-space model of a robot joint"""\n    \n    def __init__(self, inertia=1.0, damping=0.5, stiffness=0.0):\n        # Joint dynamics: J\u03b8\u0308 + B\u03b8\u0307 + K\u03b8 = \u03c4\n        # State: x = [\u03b8, \u03b8\u0307]\n        # Input: u = \u03c4 (torque)\n        \n        self.inertia = inertia\n        self.damping = damping\n        self.stiffness = stiffness\n        \n        # State-space matrices\n        self.A = np.array([\n            [0, 1],\n            [-stiffness/inertia, -damping/inertia]\n        ])\n        \n        self.B = np.array([\n            [0],\n            [1/inertia]\n        ])\n        \n        self.C = np.array([[1, 0]])  # Measure position\n        self.D = np.array([[0]])\n        \n        self.system = StateSpaceSystem(self.A, self.B, self.C, self.D)\n    \n    def simulate_response(self, controller, setpoint, duration=5.0, dt=0.01):\n        """Simulate closed-loop response"""\n        steps = int(duration / dt)\n        time_history = []\n        position_history = []\n        setpoint_history = []\n        control_history = []\n        \n        # Reset system\n        self.system.reset()\n        \n        for i in range(steps):\n            current_time = i * dt\n            \n            # Get current position\n            current_position = self.system.state[0]\n            \n            # Calculate control (state feedback)\n            state_error = np.array([setpoint - current_position, -self.system.state[1]])\n            control_signal = -controller @ state_error\n            \n            # Update system\n            output = self.system.update(control_signal, dt)\n            \n            # Store results\n            time_history.append(current_time)\n            position_history.append(output[0])\n            setpoint_history.append(setpoint)\n            control_history.append(control_signal[0])\n        \n        return time_history, position_history, setpoint_history, control_history\n\n# Example: Design and test state-space controllers\njoint = RobotJointModel(inertia=1.0, damping=0.5, stiffness=2.0)\n\n# Design LQR controller\nQ = np.diag([10, 1])  # Position and velocity weights\nR = np.array([[0.1]])   # Control effort weight\n\nK_lqr, P = StateSpaceController.lqr_design(joint.A, joint.B, Q, R)\n\nprint("LQR Controller Gain Matrix:")\nprint(K_lqr)\n\n# Simulate response\ntime, position, setpoint, control = joint.simulate_response(\n    K_lqr, setpoint=1.0, duration=5.0\n)\n\n# Plot results\nplt.figure(figsize=(12, 8))\n\nplt.subplot(2, 1, 1)\nplt.plot(time, position, \'b-\', label=\'Position\')\nplt.plot(time, setpoint, \'r--\', label=\'Setpoint\')\nplt.xlabel(\'Time (s)\')\nplt.ylabel(\'Position (rad)\')\nplt.title(\'LQR Control Response\')\nplt.legend()\nplt.grid(True)\n\nplt.subplot(2, 1, 2)\nplt.plot(time, control, \'g-\', label=\'Control Signal\')\nplt.xlabel(\'Time (s)\')\nplt.ylabel(\'Torque (Nm)\')\nplt.title(\'Control Signal\')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,i.jsx)(e.h3,{id:"optimal-control",children:"Optimal Control"}),"\n",(0,i.jsx)(e.p,{children:"Optimal control finds control inputs that minimize a cost function while satisfying system dynamics:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Linear Quadratic Regulator (LQR)"}),": Minimizes quadratic cost for linear systems\n",(0,i.jsx)(e.strong,{children:"Model Predictive Control (MPC)"}),": Solves optimization problem over prediction horizon\n",(0,i.jsx)(e.strong,{children:"Optimal Estimation"}),": Kalman filter for optimal state estimation"]}),"\n",(0,i.jsx)(e.h2,{id:"advanced-control-strategies",children:"Advanced Control Strategies"}),"\n",(0,i.jsx)(e.h3,{id:"adaptive-control",children:"Adaptive Control"}),"\n",(0,i.jsx)(e.p,{children:"Adaptive control adjusts controller parameters in real-time to handle system uncertainties and parameter variations."}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Model Reference Adaptive Control (MRAC)"}),": System follows reference model behavior\n",(0,i.jsx)(e.strong,{children:"Self-Tuning Regulators"}),": Estimate system parameters and update controller\n",(0,i.jsx)(e.strong,{children:"Gain Scheduling"}),": Switch between different controllers based on operating conditions"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class AdaptiveController:\n    \"\"\"Model Reference Adaptive Control implementation\"\"\"\n    \n    def __init__(self, reference_model, adaptation_gain=0.1):\n        self.reference_model = reference_model\n        self.adaptation_gain = adaptation_gain\n        \n        # Adaptive parameters\n        self.theta = np.zeros(2)  # [proportional_gain, derivative_gain]\n        \n        # Reference model state\n        self.ref_state = 0.0\n        self.ref_velocity = 0.0\n        \n    def update_reference_model(self, setpoint, dt):\n        \"\"\"Update reference model dynamics\"\"\"\n        # Simple second-order reference model\n        omega_n = 2.0  # Natural frequency\n        zeta = 0.7     # Damping ratio\n        \n        # Reference model: \u1e8d + 2\u03b6\u03c9\u2099\u1e8b + \u03c9\u2099\xb2x = \u03c9\u2099\xb2r\n        ref_accel = omega_n**2 * (setpoint - self.ref_state) - 2*zeta*omega_n*self.ref_velocity\n        \n        self.ref_velocity += ref_accel * dt\n        self.ref_state += self.ref_velocity * dt\n        \n        return self.ref_state\n    \n    def adapt_parameters(self, error, state_vector):\n        \"\"\"Update adaptive parameters using gradient descent\"\"\"\n        # Adaptation law: \u03b8\u0307 = -\u03b3 * e * \u03c6\n        # where e is tracking error and \u03c6 is regressor vector\n        adaptation = -self.adaptation_gain * error * state_vector\n        self.theta += adaptation * 0.01  # Assuming dt = 0.01\n        \n        # Limit parameter values for stability\n        self.theta[0] = np.clip(self.theta[0], 0.1, 50.0)  # Proportional gain\n        self.theta[1] = np.clip(self.theta[1], 0.0, 10.0)  # Derivative gain\n    \n    def compute_control(self, setpoint, measured_position, measured_velocity, dt):\n        \"\"\"Compute adaptive control signal\"\"\"\n        # Update reference model\n        ref_position = self.update_reference_model(setpoint, dt)\n        \n        # Tracking error\n        error = measured_position - ref_position\n        \n        # Regressor vector [position, velocity]\n        state_vector = np.array([measured_position, measured_velocity])\n        \n        # Adapt parameters\n        self.adapt_parameters(error, state_vector)\n        \n        # Compute control: u = -\u03b8\u1d40\u03c6\n        control_signal = -np.dot(self.theta, state_vector)\n        \n        return control_signal, ref_position\n\nclass AdaptiveRobotController:\n    \"\"\"Adaptive controller for humanoid robot joints\"\"\"\n    \n    def __init__(self, joint_names, initial_params=None):\n        self.controllers = {}\n        self.joint_names = joint_names\n        \n        for joint in joint_names:\n            params = initial_params.get(joint, {'kp': 10.0, 'kd': 1.0})\n            self.controllers[joint] = AdaptiveController(\n                reference_model={'omega_n': 2.0, 'zeta': 0.7},\n                adaptation_gain=0.05\n            )\n            # Initialize with reasonable parameters\n            self.controllers[joint].theta = np.array([params['kp'], params['kd']])\n    \n    def control_step(self, setpoints, measured_states, dt):\n        \"\"\"Compute control outputs for all joints\"\"\"\n        control_outputs = {}\n        reference_positions = {}\n        \n        for joint in self.joint_names:\n            setpoint = setpoints.get(joint, 0.0)\n            measured_pos = measured_states[joint]['position']\n            measured_vel = measured_states[joint]['velocity']\n            \n            control_signal, ref_pos = self.controllers[joint].compute_control(\n                setpoint, measured_pos, measured_vel, dt\n            )\n            \n            control_outputs[joint] = control_signal\n            reference_positions[joint] = ref_pos\n        \n        return control_outputs, reference_positions\n\n# Example simulation of adaptive control\ndef simulate_adaptive_control():\n    \"\"\"Simulate adaptive control for a robot joint\"\"\"\n    # System parameters (unknown to controller)\n    true_inertia = 2.0\n    true_damping = 1.5\n    \n    # Create adaptive controller\n    controller = AdaptiveController(['joint1'])\n    \n    # Simulation parameters\n    dt = 0.01\n    duration = 10.0\n    steps = int(duration / dt)\n    \n    # Storage for results\n    time_history = []\n    position_history = []\n    setpoint_history = []\n    parameter_history = []\n    \n    # System state\n    position = 0.0\n    velocity = 0.0\n    \n    for i in range(steps):\n        current_time = i * dt\n        \n        # Setpoint (changes over time)\n        if current_time < 3.0:\n            setpoint = 1.0\n        elif current_time < 6.0:\n            setpoint = -1.0\n        else:\n            setpoint = 0.5\n        \n        # Get control signal\n        control_signal, ref_pos = controller.controllers['joint1'].compute_control(\n            setpoint, position, velocity, dt\n        )\n        \n        # System dynamics (simplified)\n        acceleration = (control_signal - true_damping * velocity) / true_inertia\n        velocity += acceleration * dt\n        position += velocity * dt\n        \n        # Store results\n        time_history.append(current_time)\n        position_history.append(position)\n        setpoint_history.append(setpoint)\n        parameter_history.append(controller.controllers['joint1'].theta.copy())\n    \n    return time_history, position_history, setpoint_history, parameter_history\n\n# Run simulation\ntime, position, setpoint, params = simulate_adaptive_control()\n\n# Plot results\nplt.figure(figsize=(15, 10))\n\nplt.subplot(3, 1, 1)\nplt.plot(time, position, 'b-', label='Actual Position')\nplt.plot(time, setpoint, 'r--', label='Setpoint')\nplt.xlabel('Time (s)')\nplt.ylabel('Position (rad)')\nplt.title('Adaptive Control Response')\nplt.legend()\nplt.grid(True)\n\nplt.subplot(3, 1, 2)\nparams_array = np.array(params)\nplt.plot(time, params_array[:, 0], 'g-', label='Proportional Gain')\nplt.xlabel('Time (s)')\nplt.ylabel('Gain')\nplt.title('Adaptive Parameter Evolution')\nplt.legend()\nplt.grid(True)\n\nplt.subplot(3, 1, 3)\nplt.plot(time, params_array[:, 1], 'm-', label='Derivative Gain')\nplt.xlabel('Time (s)')\nplt.ylabel('Gain')\nplt.title('Derivative Gain Adaptation')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,i.jsx)(e.h3,{id:"robust-control",children:"Robust Control"}),"\n",(0,i.jsx)(e.p,{children:"Robust control maintains performance despite model uncertainties and disturbances:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"H-infinity Control"}),": Minimizes worst-case error for bounded uncertainties\n",(0,i.jsx)(e.strong,{children:"Sliding Mode Control"}),": Provides robustness to parameter variations\n",(0,i.jsx)(e.strong,{children:"Gain Scheduling"}),": Adapts controller based on operating conditions"]}),"\n",(0,i.jsx)(e.h3,{id:"nonlinear-control",children:"Nonlinear Control"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots exhibit significant nonlinear dynamics requiring specialized control approaches:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Feedback Linearization"}),": Cancels nonlinearities to create linear system\n",(0,i.jsx)(e.strong,{children:"Computed Torque Control"}),": Uses dynamic model to compute required torques\n",(0,i.jsx)(e.strong,{children:"Passivity-Based Control"}),": Exploits energy properties for stability"]}),"\n",(0,i.jsx)(e.h2,{id:"control-system-analysis",children:"Control System Analysis"}),"\n",(0,i.jsx)(e.h3,{id:"stability-analysis",children:"Stability Analysis"}),"\n",(0,i.jsx)(e.p,{children:"Stability is fundamental for safe robot operation:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Lyapunov Stability"}),": Energy-based stability analysis\n",(0,i.jsx)(e.strong,{children:"BIBO Stability"}),": Bounded input produces bounded output\n",(0,i.jsx)(e.strong,{children:"Phase Margin"}),": Frequency-domain stability measure\n",(0,i.jsx)(e.strong,{children:"Gain Margin"}),": Robustness to gain variations"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class StabilityAnalyzer:\n    """Tools for analyzing control system stability"""\n    \n    @staticmethod\n    def lyapunov_analysis(A, Q):\n        """Analyze stability using Lyapunov equation"""\n        # Solve Lyapunov equation: A\u1d40P + PA = -Q\n        from scipy import linalg\n        \n        try:\n            P = linalg.solve_continuous_lyapunov(A.T, -Q)\n            \n            # Check if P is positive definite\n            eigenvalues = np.linalg.eigvals(P)\n            \n            if np.all(eigenvalues > 0):\n                return True, P, eigenvalues\n            else:\n                return False, P, eigenvalues\n                \n        except:\n            return False, None, None\n    \n    @staticmethod\n    def pole_analysis(A):\n        """Analyze system poles for stability"""\n        eigenvalues = np.linalg.eigvals(A)\n        \n        # Check if all poles have negative real parts\n        stable = np.all(np.real(eigenvalues) < 0)\n        \n        return stable, eigenvalues\n    \n    @staticmethod\n    def frequency_response(A, B, C, D, frequencies):\n        """Calculate frequency response of state-space system"""\n        import scipy.signal as signal\n        \n        # Convert to transfer function\n        num, den = signal.ss2tf(A, B, C, D)\n        \n        # Calculate frequency response\n        w, mag, phase = signal.bode((num, den), w=frequencies)\n        \n        return w, mag, phase\n    \n    @staticmethod\n    def gain_phase_margins(A, B, C, D):\n        """Calculate gain and phase margins"""\n        import scipy.signal as signal\n        \n        # Get frequency response\n        w, mag, phase = StabilityAnalyzer.frequency_response(A, B, C, D, \n                                                           np.logspace(-2, 2, 1000))\n        \n        # Find gain margin (where phase = -180\xb0)\n        phase_crossings = np.where(np.diff(np.sign(phase + 180)))[0]\n        \n        if len(phase_crossings) > 0:\n            crossing_idx = phase_crossings[0]\n            gain_margin_db = -mag[crossing_idx]\n            gain_margin_freq = w[crossing_idx]\n        else:\n            gain_margin_db = np.inf\n            gain_margin_freq = np.nan\n        \n        # Find phase margin (where gain = 0dB)\n        gain_crossings = np.where(np.diff(np.sign(mag)))[0]\n        \n        if len(gain_crossings) > 0:\n            crossing_idx = gain_crossings[0]\n            phase_margin = 180 + phase[crossing_idx]\n            phase_margin_freq = w[crossing_idx]\n        else:\n            phase_margin = np.inf\n            phase_margin_freq = np.nan\n        \n        return {\n            \'gain_margin_db\': gain_margin_db,\n            \'gain_margin_freq\': gain_margin_freq,\n            \'phase_margin_deg\': phase_margin,\n            \'phase_margin_freq\': phase_margin_freq\n        }\n\n# Example: Stability analysis of a robot joint controller\njoint = RobotJointModel(inertia=1.0, damping=0.5, stiffness=2.0)\n\n# Design LQR controller\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nK, P = StateSpaceController.lqr_design(joint.A, joint.B, Q, R)\n\n# Closed-loop system matrix\nA_cl = joint.A - joint.B @ K\n\n# Analyze stability\nanalyzer = StabilityAnalyzer()\n\n# Pole analysis\nstable_poles, poles = analyzer.pole_analysis(A_cl)\nprint(f"Closed-loop poles: {poles}")\nprint(f"System stable: {stable_poles}")\n\n# Lyapunov analysis\nQ_lyap = np.eye(2)\nstable_lyap, P_lyap, eigenvals = analyzer.lyapunov_analysis(A_cl, Q_lyap)\nprint(f"Lyapunov stable: {stable_lyap}")\nif P_lyap is not None:\n    print(f"Lyapunov eigenvalues: {eigenvals}")\n\n# Gain and phase margins\nmargins = analyzer.gain_phase_margins(joint.A, joint.B, K, np.zeros((1, 1)))\nprint(f"Gain margin: {margins[\'gain_margin_db\']:.2f} dB")\nprint(f"Phase margin: {margins[\'phase_margin_deg\']:.2f} degrees")\n'})}),"\n",(0,i.jsx)(e.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsx)(e.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,i.jsx)(e.p,{children:"Whole-body control coordinates multiple joints to achieve complex tasks while maintaining constraints:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Task Space Control"}),": Control end-effector position/orientation\n",(0,i.jsx)(e.strong,{children:"Null Space Control"}),": Handle redundant degrees of freedom\n",(0,i.jsx)(e.strong,{children:"Hierarchical Control"}),": Prioritize different tasks"]}),"\n",(0,i.jsx)(e.h3,{id:"balance-control",children:"Balance Control"}),"\n",(0,i.jsx)(e.p,{children:"Balance control maintains robot stability during locomotion and manipulation:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Keep center of pressure within support polygon\n",(0,i.jsx)(e.strong,{children:"Center of Mass Control"}),": Adjust body position for stability\n",(0,i.jsx)(e.strong,{children:"Capture Point"}),": Predict and prevent falls"]}),"\n",(0,i.jsx)(e.h3,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,i.jsx)(e.p,{children:"Impedance control modulates robot mechanical properties for safe interaction:"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Admittance Control"}),": Control force response to motion\n",(0,i.jsx)(e.strong,{children:"Stiffness Control"}),": Adjust joint stiffness\n",(0,i.jsx)(e.strong,{children:"Damping Control"}),": Control energy dissipation"]}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-1-pid-controller-tuning",children:"Exercise 1: PID Controller Tuning"}),"\n",(0,i.jsx)(e.p,{children:"Design and tune PID controllers for a 3-DOF robot arm. Consider:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Different dynamics for each joint"}),"\n",(0,i.jsx)(e.li,{children:"Coupling between joints"}),"\n",(0,i.jsx)(e.li,{children:"Performance requirements (rise time, overshoot, steady-state error)"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-2-state-space-controller-design",children:"Exercise 2: State-Space Controller Design"}),"\n",(0,i.jsx)(e.p,{children:"Design state-space controllers for a humanoid robot leg model:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Linearize the nonlinear dynamics around operating points"}),"\n",(0,i.jsx)(e.li,{children:"Design LQR controllers for different configurations"}),"\n",(0,i.jsx)(e.li,{children:"Compare performance with PID controllers"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-3-adaptive-control-implementation",children:"Exercise 3: Adaptive Control Implementation"}),"\n",(0,i.jsx)(e.p,{children:"Implement an adaptive controller for a robot joint with unknown parameters:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Simulate parameter variations during operation"}),"\n",(0,i.jsx)(e.li,{children:"Compare adaptive vs. fixed-gain controller performance"}),"\n",(0,i.jsx)(e.li,{children:"Analyze convergence and stability"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-4-balance-control-design",children:"Exercise 4: Balance Control Design"}),"\n",(0,i.jsx)(e.p,{children:"Design a balance controller for a simplified humanoid robot:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement ZMP-based balance control"}),"\n",(0,i.jsx)(e.li,{children:"Add disturbance rejection capabilities"}),"\n",(0,i.jsx)(e.li,{children:"Test stability under various conditions"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Control theory provides the mathematical foundation for making humanoid robots move precisely, safely, and intelligently. From classical PID control to advanced adaptive and robust methods, control systems determine how robots respond to commands and disturbances."}),"\n",(0,i.jsx)(e.p,{children:"Key concepts include feedback control principles, state-space methods for multi-variable systems, optimal control for performance optimization, and adaptive/robust techniques for handling uncertainties. Stability analysis ensures safe operation, while practical applications like whole-body control and balance management enable complex humanoid behaviors."}),"\n",(0,i.jsx)(e.p,{children:"As humanoid robots become more sophisticated, control systems must handle increasing complexity while maintaining safety and performance. The integration of learning-based methods with traditional control theory promises to expand the capabilities of future humanoid robots, enabling them to adapt to new situations and learn from experience."}),"\n",(0,i.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(e.p,{children:['[1] \xc5str\xf6m, K.J. and Murray, R.M. "Feedback Systems: An Introduction for Scientists and Engineers", 2nd Edition, Princeton University Press, 2023. ',(0,i.jsx)(e.a,{href:"https://doi.org/10.2307/j.ctv19sb9k4",children:"https://doi.org/10.2307/j.ctv19sb9k4"})]}),"\n",(0,i.jsxs)(e.p,{children:['[2] Slotine, J.J.E. and Li, W. "Applied Nonlinear Control", Prentice Hall, 2022. ',(0,i.jsx)(e.a,{href:"https://doi.org/10.1016/B978-0-12-382032-7.00012-8",children:"https://doi.org/10.1016/B978-0-12-382032-7.00012-8"})]}),"\n",(0,i.jsxs)(e.p,{children:['[3] Khalil, H.K. "Nonlinear Systems", 4th Edition, Pearson, 2022. ',(0,i.jsx)(e.a,{href:"https://doi.org/10.1016/B978-0-12-815412-0.00015-6",children:"https://doi.org/10.1016/B978-0-12-815412-0.00015-6"})]}),"\n",(0,i.jsxs)(e.p,{children:['[4] Siciliano, B. and Khatib, O. "Springer Handbook of Robotics", 2nd Edition, Springer, 2021. ',(0,i.jsx)(e.a,{href:"https://doi.org/10.1007/978-3-030-90205-3",children:"https://doi.org/10.1007/978-3-030-90205-3"})]}),"\n",(0,i.jsxs)(e.p,{children:['[5] ROS 2 Documentation, "Control System Libraries", 2025. ',(0,i.jsx)(e.a,{href:"https://docs.ros.org/en/rolling/",children:"https://docs.ros.org/en/rolling/"})]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);