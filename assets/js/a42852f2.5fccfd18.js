"use strict";(globalThis.webpackChunkphysical_and_humanoid_robotics_book=globalThis.webpackChunkphysical_and_humanoid_robotics_book||[]).push([[35],{2982:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"humanoid-design/degrees-freedom","title":"Degrees of Freedom and Kinematic Chains","description":"Comprehensive guide to degrees of freedom analysis and kinematic chain design for humanoid robots","source":"@site/docs/03-humanoid-design/02-degrees-freedom.mdx","sourceDirName":"03-humanoid-design","slug":"/humanoid-design/degrees-freedom","permalink":"/Robotics-Book/docs/humanoid-design/degrees-freedom","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-humanoid-design/02-degrees-freedom.mdx","tags":[{"inline":true,"label":"degrees-of-freedom","permalink":"/Robotics-Book/docs/tags/degrees-of-freedom"},{"inline":true,"label":"kinematics","permalink":"/Robotics-Book/docs/tags/kinematics"},{"inline":true,"label":"robot-design","permalink":"/Robotics-Book/docs/tags/robot-design"},{"inline":true,"label":"humanoid-robotics","permalink":"/Robotics-Book/docs/tags/humanoid-robotics"}],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Degrees of Freedom and Kinematic Chains","sidebar_label":"Degrees of Freedom and Kinematic Chains","description":"Comprehensive guide to degrees of freedom analysis and kinematic chain design for humanoid robots","hide_table_of_contents":false,"authors":["Robotics Book Team"],"tags":["degrees-of-freedom","kinematics","robot-design","humanoid-robotics"],"reading_time":26,"difficulty":"advanced","prerequisites":["01-kinematics-dynamics","01-anthropomorphic-design"],"learning_objectives":["Understand degrees of freedom analysis for robotic systems","Apply Gr\xfcbler\'s equation to mobile mechanisms","Design kinematic chains for humanoid robots","Analyze redundancy and task space requirements","Optimize joint configurations for specific applications"]},"sidebar":"bookSidebar","previous":{"title":"Anthropomorphic Design Principles","permalink":"/Robotics-Book/docs/humanoid-design/anthropomorphic-design"},"next":{"title":"Balance & Gait Control","permalink":"/Robotics-Book/docs/humanoid-design/balance-gait"}}');var s=i(4848),o=i(8453);const t={title:"Degrees of Freedom and Kinematic Chains",sidebar_label:"Degrees of Freedom and Kinematic Chains",description:"Comprehensive guide to degrees of freedom analysis and kinematic chain design for humanoid robots",hide_table_of_contents:!1,authors:["Robotics Book Team"],tags:["degrees-of-freedom","kinematics","robot-design","humanoid-robotics"],reading_time:26,difficulty:"advanced",prerequisites:["01-kinematics-dynamics","01-anthropomorphic-design"],learning_objectives:["Understand degrees of freedom analysis for robotic systems","Apply Gr\xfcbler's equation to mobile mechanisms","Design kinematic chains for humanoid robots","Analyze redundancy and task space requirements","Optimize joint configurations for specific applications"]},l="Degrees of Freedom and Kinematic Chains",r={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Degrees of Freedom Fundamentals",id:"degrees-of-freedom-fundamentals",level:2},{value:"Definition and Importance",id:"definition-and-importance",level:3},{value:"Types of Joints and Their DOF",id:"types-of-joints-and-their-dof",level:3},{value:"Gr\xfcbler&#39;s Equation",id:"gr\xfcblers-equation",level:3},{value:"Kinematic Chain Design",id:"kinematic-chain-design",level:2},{value:"Serial vs. Parallel Mechanisms",id:"serial-vs-parallel-mechanisms",level:3},{value:"Workspace Analysis",id:"workspace-analysis",level:3},{value:"Redundancy and Optimization",id:"redundancy-and-optimization",level:2},{value:"Kinematic Redundancy",id:"kinematic-redundancy",level:3},{value:"Redundancy Resolution",id:"redundancy-resolution",level:3},{value:"Task Space Analysis",id:"task-space-analysis",level:2},{value:"Task Space Requirements",id:"task-space-requirements",level:3},{value:"Workspace Optimization",id:"workspace-optimization",level:3},{value:"Practical Design Examples",id:"practical-design-examples",level:2},{value:"Humanoid Arm Configuration",id:"humanoid-arm-configuration",level:3},{value:"Humanoid Leg Configuration",id:"humanoid-leg-configuration",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: DOF Analysis",id:"exercise-1-dof-analysis",level:3},{value:"Exercise 2: Workspace Calculation",id:"exercise-2-workspace-calculation",level:3},{value:"Exercise 3: Redundancy Resolution",id:"exercise-3-redundancy-resolution",level:3},{value:"Exercise 4: Optimization Problem",id:"exercise-4-optimization-problem",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function c(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"degrees-of-freedom-and-kinematic-chains",children:"Degrees of Freedom and Kinematic Chains"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand degrees of freedom analysis for robotic systems"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply Gr\xfcbler's equation to mobile mechanisms"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Design kinematic chains for humanoid robots"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Analyze redundancy and task space requirements"]}),"\n",(0,s.jsxs)(e.li,{className:"task-list-item",children:[(0,s.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Optimize joint configurations for specific applications"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Degrees of freedom (DOF) represent the independent parameters that define the configuration of a robotic system. For humanoid robots, understanding and optimizing DOF is crucial for achieving human-like mobility and manipulation capabilities. The human body possesses over 600 muscles controlling approximately 244 DOF, creating an incredibly flexible and adaptable system."}),"\n",(0,s.jsx)(e.p,{children:"This module explores the mathematical foundations of DOF analysis, kinematic chain design principles, and optimization strategies for humanoid robots. We'll examine how to balance complexity with functionality, ensuring robots have sufficient mobility without unnecessary mechanical complexity or control challenges."}),"\n",(0,s.jsx)(e.h2,{id:"degrees-of-freedom-fundamentals",children:"Degrees of Freedom Fundamentals"}),"\n",(0,s.jsx)(e.h3,{id:"definition-and-importance",children:"Definition and Importance"}),"\n",(0,s.jsx)(e.p,{children:"Degrees of freedom represent the number of independent parameters needed to uniquely specify the position and orientation of all bodies in a mechanical system. For humanoid robots, DOF determine:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Mobility Capabilities"}),": Range of possible movements and configurations\n",(0,s.jsx)(e.strong,{children:"Task Space Dimensionality"}),": Types of tasks the robot can perform\n",(0,s.jsx)(e.strong,{children:"Control Complexity"}),": Number of independently controlled joints\n",(0,s.jsx)(e.strong,{children:"Redundancy"}),": Extra DOF beyond minimum requirements\n",(0,s.jsx)(e.strong,{children:"Singularities"}),": Configurations where mobility is reduced"]}),"\n",(0,s.jsx)(e.h3,{id:"types-of-joints-and-their-dof",children:"Types of Joints and Their DOF"}),"\n",(0,s.jsx)(e.p,{children:"Different joint types contribute different numbers of DOF:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Revolute Joint (R)"}),": 1 DOF - rotation about a single axis"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Most common in humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Simple to implement and control"}),"\n",(0,s.jsx)(e.li,{children:"Examples: elbow, knee, finger joints"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Prismatic Joint (P)"}),": 1 DOF - linear translation along an axis"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Less common in humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Used for linear actuators and sliding mechanisms"}),"\n",(0,s.jsx)(e.li,{children:"Examples: telescoping limbs, linear slides"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Cylindrical Joint (C)"}),": 2 DOF - rotation and translation about same axis"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Combines revolute and prismatic motion"}),"\n",(0,s.jsx)(e.li,{children:"Rare in humanoid robots"}),"\n",(0,s.jsx)(e.li,{children:"Examples: shoulder elevation with rotation"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Planar Joint"}),": 3 DOF - translation in plane plus rotation about normal"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Allows movement in two-dimensional plane"}),"\n",(0,s.jsx)(e.li,{children:"Used for mobile platforms"}),"\n",(0,s.jsx)(e.li,{children:"Examples: planar mechanisms"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Spherical Joint (S)"}),": 3 DOF - rotation about three perpendicular axes"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Ball-and-socket configuration"}),"\n",(0,s.jsx)(e.li,{children:"Critical for shoulder and hip joints"}),"\n",(0,s.jsx)(e.li,{children:"Provides maximum rotational mobility"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Universal Joint (U)"}),": 2 DOF - rotation about two perpendicular axes"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Cross-shaped joint configuration"}),"\n",(0,s.jsx)(e.li,{children:"Used for wrist and ankle joints"}),"\n",(0,s.jsx)(e.li,{children:"Simpler than spherical joint"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"gr\xfcblers-equation",children:"Gr\xfcbler's Equation"}),"\n",(0,s.jsx)(e.p,{children:"Gr\xfcbler's equation calculates the theoretical DOF for planar and spatial mechanisms:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Planar Mechanisms"}),":\nDOF = 3(N - 1) - 2*J1 - J2"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Spatial Mechanisms"}),":\nDOF = 6(N - 1) - 5",(0,s.jsx)(e.em,{children:"J1 - 4"}),"J2 - 3",(0,s.jsx)(e.em,{children:"J3 - 2"}),"J4 - J5"]}),"\n",(0,s.jsx)(e.p,{children:"Where:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"N = number of links (including ground)"}),"\n",(0,s.jsx)(e.li,{children:"J1 = number of 1-DOF joints"}),"\n",(0,s.jsx)(e.li,{children:"J2 = number of 2-DOF joints"}),"\n",(0,s.jsx)(e.li,{children:"J3 = number of 3-DOF joints"}),"\n",(0,s.jsx)(e.li,{children:"J4 = number of 4-DOF joints"}),"\n",(0,s.jsx)(e.li,{children:"J5 = number of 5-DOF joints"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import numpy as np\n\nclass DOFAnalyzer:\n    \"\"\"Analyze degrees of freedom for robotic mechanisms\"\"\"\n    \n    def __init__(self):\n        self.joint_dof = {\n            'revolute': 1,\n            'prismatic': 1,\n            'cylindrical': 2,\n            'planar': 3,\n            'spherical': 3,\n            'universal': 2\n        }\n    \n    def gruebler_planar(self, num_links, joint_counts):\n        \"\"\"Calculate DOF for planar mechanism using Gr\xfcbler's equation\"\"\"\n        # DOF = 3(N - 1) - 2J\u2081 - J\u2082\n        total_joints = sum(joint_counts.values())\n        j1 = joint_counts.get('revolute', 0) + joint_counts.get('prismatic', 0)\n        j2 = joint_counts.get('cylindrical', 0)\n        \n        dof = 3 * (num_links - 1) - 2 * j1 - j2\n        return dof\n    \n    def gruebler_spatial(self, num_links, joint_counts):\n        \"\"\"Calculate DOF for spatial mechanism using Gr\xfcbler's equation\"\"\"\n        # DOF = 6(N - 1) - 5J\u2081 - 4J\u2082 - 3J\u2083 - 2J\u2084 - J\u2085\n        j1 = joint_counts.get('revolute', 0) + joint_counts.get('prismatic', 0)\n        j2 = joint_counts.get('cylindrical', 0) + joint_counts.get('universal', 0)\n        j3 = joint_counts.get('spherical', 0)\n        j4 = joint_counts.get('planar', 0)\n        j5 = 0  # 5-DOF joints are rare\n        \n        dof = 6 * (num_links - 1) - 5 * j1 - 4 * j2 - 3 * j3 - 2 * j4 - j5\n        return dof\n    \n    def analyze_humanoid_dof(self, configuration):\n        \"\"\"Analyze DOF for humanoid robot configuration\"\"\"\n        total_dof = 0\n        joint_breakdown = {}\n        \n        for limb, joints in configuration.items():\n            limb_dof = 0\n            limb_joints = {}\n            \n            for joint_type, count in joints.items():\n                joint_dof = self.joint_dof.get(joint_type, 0)\n                limb_dof += joint_dof * count\n                limb_joints[joint_type] = {\n                    'count': count,\n                    'dof_per_joint': joint_dof,\n                    'total_dof': joint_dof * count\n                }\n            \n            joint_breakdown[limb] = limb_joints\n            total_dof += limb_dof\n        \n        return {\n            'total_dof': total_dof,\n            'joint_breakdown': joint_breakdown,\n            'limb_dof': {limb: sum(j['total_dof'] for j in joints.values()) \n                         for limb, joints in joint_breakdown.items()}\n        }\n    \n    def calculate_mobility_index(self, dof_analysis):\n        \"\"\"Calculate mobility indices for performance evaluation\"\"\"\n        total_dof = dof_analysis['total_dof']\n        \n        # Task space requirements\n        task_space_requirements = {\n            'leg_locomotion': 6,    # 3 position + 3 orientation\n            'arm_manipulation': 6,   # 3 position + 3 orientation\n            'head_orientation': 3,    # 3 orientation\n            'body_posture': 6         # 3 position + 3 orientation\n        }\n        \n        # Calculate redundancy\n        min_required_dof = sum(task_space_requirements.values())\n        redundancy = total_dof - min_required_dof\n        \n        # Mobility indices\n        mobility_index = {\n            'total_dof': total_dof,\n            'minimum_required': min_required_dof,\n            'redundancy': redundancy,\n            'redundancy_ratio': redundancy / min_required_dof if min_required_dof > 0 else 0,\n            'complexity_factor': total_dof / 30  # Normalized to typical humanoid\n        }\n        \n        return mobility_index\n\n# Example usage\nanalyzer = DOFAnalyzer()\n\n# Define humanoid robot configuration\nhumanoid_config = {\n    'left_leg': {\n        'hip': {'spherical': 1},      # 3 DOF\n        'knee': {'revolute': 1},      # 1 DOF\n        'ankle': {'universal': 1}      # 2 DOF\n    },\n    'right_leg': {\n        'hip': {'spherical': 1},      # 3 DOF\n        'knee': {'revolute': 1},      # 1 DOF\n        'ankle': {'universal': 1}      # 2 DOF\n    },\n    'left_arm': {\n        'shoulder': {'spherical': 1},   # 3 DOF\n        'elbow': {'revolute': 1},      # 1 DOF\n        'wrist': {'universal': 1}      # 2 DOF\n    },\n    'right_arm': {\n        'shoulder': {'spherical': 1},   # 3 DOF\n        'elbow': {'revolute': 1},      # 1 DOF\n        'wrist': {'universal': 1}      # 2 DOF\n    },\n    'torso': {\n        'waist': {'revolute': 3}       # 3 DOF (yaw, pitch, roll)\n    },\n    'head': {\n        'neck': {'spherical': 1}        # 3 DOF\n    }\n}\n\n# Analyze DOF\ndof_analysis = analyzer.analyze_humanoid_dof(humanoid_config)\nmobility = analyzer.calculate_mobility_index(dof_analysis)\n\nprint(\"Humanoid Robot DOF Analysis:\")\nprint(f\"Total DOF: {dof_analysis['total_dof']}\")\nprint(\"\\nDOF by Limb:\")\nfor limb, dof in dof_analysis['limb_dof'].items():\n    print(f\"  {limb}: {dof} DOF\")\n\nprint(\"\\nMobility Indices:\")\nfor key, value in mobility.items():\n    print(f\"  {key}: {value:.2f}\")\n"})}),"\n",(0,s.jsx)(e.h2,{id:"kinematic-chain-design",children:"Kinematic Chain Design"}),"\n",(0,s.jsx)(e.h3,{id:"serial-vs-parallel-mechanisms",children:"Serial vs. Parallel Mechanisms"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Serial Chains"}),": Joints connected in series like links in a chain"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Simple kinematic analysis"}),"\n",(0,s.jsx)(e.li,{children:"Large workspace"}),"\n",(0,s.jsx)(e.li,{children:"Accumulated errors"}),"\n",(0,s.jsx)(e.li,{children:"Lower stiffness"}),"\n",(0,s.jsx)(e.li,{children:"Examples: robot arms, legs"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Parallel Mechanisms"}),": Multiple chains connecting base to end-effector"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Complex kinematic analysis"}),"\n",(0,s.jsx)(e.li,{children:"Limited workspace"}),"\n",(0,s.jsx)(e.li,{children:"High stiffness and precision"}),"\n",(0,s.jsx)(e.li,{children:"Distributed errors"}),"\n",(0,s.jsx)(e.li,{children:"Examples: Stewart platforms, delta robots"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hybrid Mechanisms"}),": Combination of serial and parallel"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Balanced performance"}),"\n",(0,s.jsx)(e.li,{children:"Moderate complexity"}),"\n",(0,s.jsx)(e.li,{children:"Optimized for specific tasks"}),"\n",(0,s.jsx)(e.li,{children:"Examples: humanoid legs, torso mechanisms"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"workspace-analysis",children:"Workspace Analysis"}),"\n",(0,s.jsx)(e.p,{children:"Workspace represents the reachable space of robot end-effectors:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Reachable Workspace"}),": All positions end-effector can reach"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Determined by joint limits and link lengths"}),"\n",(0,s.jsx)(e.li,{children:"Complex three-dimensional volume for spatial mechanisms"}),"\n",(0,s.jsx)(e.li,{children:"Critical for task planning"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Dexterous Workspace"}),": Positions where end-effector can achieve all orientations"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Subset of reachable workspace"}),"\n",(0,s.jsx)(e.li,{children:"Important for manipulation tasks"}),"\n",(0,s.jsx)(e.li,{children:"Depends on joint configuration"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Manipulability"}),": Measure of how easily robot can move in different directions"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Varies throughout workspace"}),"\n",(0,s.jsx)(e.li,{children:"Maximum at center, minimum at boundaries"}),"\n",(0,s.jsx)(e.li,{children:"Influences task performance"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class WorkspaceAnalyzer:\n    """Analyze workspace of kinematic chains"""\n    \n    def __init__(self):\n        self.joint_limits = {\n            \'shoulder\': {\'min\': -180, \'max\': 180},\n            \'elbow\': {\'min\': 0, \'max\': 145},\n            \'wrist\': {\'min\': -90, \'max\': 90},\n            \'hip\': {\'min\': -120, \'max\': 45},\n            \'knee\': {\'min\': 0, \'max\': 135},\n            \'ankle\': {\'min\': -30, \'max\': 30}\n        }\n    \n    def forward_kinematics_2dof(self, link1, link2, theta1, theta2):\n        """Forward kinematics for 2-DOF planar arm"""\n        x = link1 * np.cos(theta1) + link2 * np.cos(theta1 + theta2)\n        y = link1 * np.sin(theta1) + link2 * np.sin(theta1 + theta2)\n        return x, y\n    \n    def calculate_workspace_2dof(self, link1, link2, resolution=100):\n        """Calculate reachable workspace for 2-DOF planar arm"""\n        # Generate joint angle samples\n        theta1_range = np.linspace(0, 2*np.pi, resolution)\n        theta2_range = np.linspace(0, 2*np.pi, resolution)\n        \n        workspace_points = []\n        \n        for theta1 in theta1_range:\n            for theta2 in theta2_range:\n                x, y = self.forward_kinematics_2dof(link1, link2, theta1, theta2)\n                workspace_points.append([x, y])\n        \n        return np.array(workspace_points)\n    \n    def calculate_workspace_3dof(self, link_lengths, joint_samples=50):\n        """Calculate workspace for 3-DOF spatial arm"""\n        # Simplified 3-DOF arm (R-R-R configuration)\n        l1, l2, l3 = link_lengths\n        \n        # Generate joint samples\n        theta1 = np.linspace(-np.pi, np.pi, joint_samples)\n        theta2 = np.linspace(-np.pi/2, np.pi/2, joint_samples)\n        theta3 = np.linspace(-np.pi/2, np.pi/2, joint_samples)\n        \n        workspace_points = []\n        \n        for t1 in theta1:\n            for t2 in theta2:\n                for t3 in theta3:\n                    # Simplified forward kinematics\n                    x = l1 * np.cos(t1) * np.cos(t2) + \\\n                        l2 * np.cos(t1) * np.cos(t2 + t3) + \\\n                        l3 * np.cos(t1) * np.cos(t2 + t3)\n                    \n                    y = l1 * np.sin(t1) * np.cos(t2) + \\\n                        l2 * np.sin(t1) * np.cos(t2 + t3) + \\\n                        l3 * np.sin(t1) * np.cos(t2 + t3)\n                    \n                    z = l1 * np.sin(t2) + \\\n                        l2 * np.sin(t2 + t3) + \\\n                        l3 * np.sin(t2 + t3)\n                    \n                    workspace_points.append([x, y, z])\n        \n        return np.array(workspace_points)\n    \n    def calculate_manipulability(self, jacobian):\n        """Calculate manipulability measure from Jacobian"""\n        # Yoshikawa\'s manipulability measure\n        return np.sqrt(np.linalg.det(jacobian @ jacobian.T))\n    \n    def jacobian_2dof(self, link1, link2, theta1, theta2):\n        """Calculate Jacobian for 2-DOF planar arm"""\n        J = np.array([\n            [-link1 * np.sin(theta1) - link2 * np.sin(theta1 + theta2),\n             -link2 * np.sin(theta1 + theta2)],\n            [link1 * np.cos(theta1) + link2 * np.cos(theta1 + theta2),\n             link2 * np.cos(theta1 + theta2)]\n        ])\n        return J\n    \n    def analyze_workspace_quality(self, link_lengths, grid_resolution=20):\n        """Analyze workspace quality metrics"""\n        l1, l2 = link_lengths\n        \n        # Create grid in workspace\n        max_reach = l1 + l2\n        x_range = np.linspace(-max_reach, max_reach, grid_resolution)\n        y_range = np.linspace(-max_reach, max_reach, grid_resolution)\n        \n        quality_map = np.zeros((grid_resolution, grid_resolution))\n        \n        for i, x in enumerate(x_range):\n            for j, y in enumerate(y_range):\n                # Check if point is reachable\n                distance = np.sqrt(x**2 + y**2)\n                \n                if distance <= max_reach and distance >= abs(l1 - l2):\n                    # Calculate manipulability at this point\n                    # Find joint angles that reach this point\n                    try:\n                        # Inverse kinematics (simplified)\n                        cos_theta2 = (x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2)\n                        \n                        if abs(cos_theta2) <= 1:\n                            theta2 = np.arccos(cos_theta2)\n                            theta1 = np.arctan2(y, x) - np.arctan2(l2 * np.sin(theta2),\n                                                              l1 + l2 * np.cos(theta2))\n                            \n                            # Calculate manipulability\n                            J = self.jacobian_2dof(l1, l2, theta1, theta2)\n                            manipulability = self.calculate_manipulability(J)\n                            \n                            quality_map[j, i] = manipulability\n                    except:\n                        quality_map[j, i] = 0\n                else:\n                    quality_map[j, i] = -1  # Unreachable\n        \n        return quality_map, x_range, y_range\n\n# Example usage\nworkspace_analyzer = WorkspaceAnalyzer()\n\n# Analyze 2-DOF arm workspace\nlink1, link2 = 0.3, 0.25  # meters\nworkspace_points = workspace_analyzer.calculate_workspace_2dof(link1, link2)\n\nprint(f"2-DOF Arm Workspace:")\nprint(f"Link lengths: {link1}m, {link2}m")\nprint(f"Maximum reach: {link1 + link2}m")\nprint(f"Minimum reach: {abs(link1 - link2)}m")\nprint(f"Workspace points calculated: {len(workspace_points)}")\n\n# Analyze workspace quality\nquality_map, x_range, y_range = workspace_analyzer.analyze_workspace_quality(\n    [link1, link2]\n)\n\nmax_manipulability = np.max(quality_map[quality_map >= 0])\nprint(f"Maximum manipulability: {max_manipulability:.4f}")\n'})}),"\n",(0,s.jsx)(e.h2,{id:"redundancy-and-optimization",children:"Redundancy and Optimization"}),"\n",(0,s.jsx)(e.h3,{id:"kinematic-redundancy",children:"Kinematic Redundancy"}),"\n",(0,s.jsx)(e.p,{children:"Redundancy occurs when a robot has more DOF than required for its task:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Task Space Requirements"}),": Minimum DOF needed for specific tasks"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Position control: 3 DOF (x, y, z)"}),"\n",(0,s.jsx)(e.li,{children:"Orientation control: 3 DOF (roll, pitch, yaw)"}),"\n",(0,s.jsx)(e.li,{children:"Full pose control: 6 DOF"}),"\n",(0,s.jsx)(e.li,{children:"Redundant manipulation: >6 DOF"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Benefits of Redundancy"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Obstacle avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Joint limit avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Singularity avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Optimization of secondary criteria"}),"\n",(0,s.jsx)(e.li,{children:"Fault tolerance"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Challenges of Redundancy"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Complex control algorithms"}),"\n",(0,s.jsx)(e.li,{children:"Infinite solutions for tasks"}),"\n",(0,s.jsx)(e.li,{children:"Computational complexity"}),"\n",(0,s.jsx)(e.li,{children:"Calibration difficulties"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"redundancy-resolution",children:"Redundancy Resolution"}),"\n",(0,s.jsx)(e.p,{children:"Multiple strategies exist for resolving redundancy:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Jacobian-Based Methods"}),": Use null space for secondary tasks"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Weighted pseudoinverse"}),"\n",(0,s.jsx)(e.li,{children:"Damped least squares"}),"\n",(0,s.jsx)(e.li,{children:"Task prioritization"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Optimization Methods"}),": Minimize cost functions"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Joint limit avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Manipulability maximization"}),"\n",(0,s.jsx)(e.li,{children:"Energy minimization"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Analytical Methods"}),": Closed-form solutions"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Geometric approaches"}),"\n",(0,s.jsx)(e.li,{children:"Constraint-based methods"}),"\n",(0,s.jsx)(e.li,{children:"Simplified kinematics"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class RedundancyResolver:\n    """Resolve kinematic redundancy for humanoid robots"""\n    \n    def __init__(self):\n        self.joint_limits = {\n            \'min\': np.array([-180, -90, -180, -120, 0, -30]) * np.pi/180,\n            \'max\': np.array([180, 90, 180, 45, 135, 30]) * np.pi/180\n        }\n    \n    def weighted_pseudoinverse(self, J, weights):\n        """Calculate weighted pseudoinverse of Jacobian"""\n        W = np.diag(weights)\n        J_weighted = np.linalg.inv(W) @ J.T\n        return J_weighted @ np.linalg.inv(J @ J_weighted)\n    \n    def damped_least_squares(self, J, lambda_damp=0.01):\n        """Calculate damped least squares inverse"""\n        J_T = J.T\n        return J_T @ np.linalg.inv(J @ J_T + lambda_damp**2 * np.eye(J.shape[0]))\n    \n    null_space_projector(self, J):\n        """Calculate null space projector"""\n        J_pinv = np.linalg.pinv(J)\n        return np.eye(J.shape[1]) - J_pinv @ J\n    \n    def resolve_redundancy(self, J, x_dot, secondary_task=None, \n                         method=\'weighted\', weights=None):\n        """Resolve redundancy using different methods"""\n        \n        if method == \'weighted\':\n            if weights is None:\n                weights = np.ones(J.shape[1])\n            J_pinv = self.weighted_pseudoinverse(J, weights)\n        \n        elif method == \'damped\':\n            J_pinv = self.damped_least_squares(J)\n        \n        else:  # standard pseudoinverse\n            J_pinv = np.linalg.pinv(J)\n        \n        # Primary task solution\n        q_dot_primary = J_pinv @ x_dot\n        \n        # Add secondary task if provided\n        if secondary_task is not None:\n            N = self.null_space_projector(J)\n            q_dot_secondary = N @ secondary_task\n            q_dot = q_dot_primary + q_dot_secondary\n        else:\n            q_dot = q_dot_primary\n        \n        return q_dot\n    \n    joint_limit_avoidance(self, q, q_dot, gain=1.0):\n        """Generate joint limit avoidance secondary task"""\n        # Calculate distance to joint limits\n        q_min = self.joint_limits[\'min\']\n        q_max = self.joint_limits[\'max\']\n        \n        # Avoidance potential\n        avoidance = np.zeros_like(q)\n        \n        for i in range(len(q)):\n            # Distance to limits\n            dist_to_min = q[i] - q_min[i]\n            dist_to_max = q_max[i] - q[i]\n            \n            # Avoidance velocity (move away from limits)\n            if dist_to_min < 0.1:  # Within 10 degrees of minimum\n                avoidance[i] += gain * (0.1 - dist_to_min) / dist_to_min\n            \n            if dist_to_max < 0.1:  # Within 10 degrees of maximum\n                avoidance[i] -= gain * (0.1 - dist_to_max) / dist_to_max\n        \n        return avoidance\n    \n    manipulability_gradient(self, J):\n        """Calculate gradient of manipulability measure"""\n        # Manipulability: w = sqrt(det(J @ J.T))\n        manipulability = self.calculate_manipulability(J)\n        \n        if manipulability < 1e-6:\n            return np.zeros(J.shape[1])\n        \n        # Gradient calculation (simplified)\n        J_pinv = np.linalg.pinv(J)\n        gradient = np.zeros(J.shape[1])\n        \n        # Numerical gradient\n        epsilon = 1e-6\n        for i in range(J.shape[1]):\n            J_perturbed = J.copy()\n            J_perturbed[:, i] += epsilon\n            \n            manip_perturbed = self.calculate_manipulability(J_perturbed)\n            gradient[i] = (manip_perturbed - manipulability) / epsilon\n        \n        return gradient\n    \n    def calculate_manipulability(self, J):\n        """Calculate Yoshikawa\'s manipulability measure"""\n        return np.sqrt(np.linalg.det(J @ J.T))\n\nclass HumanoidRedundancyController:\n    """Controller for redundant humanoid robot"""\n    \n    def __init__(self, num_joints=12):\n        self.resolver = RedundancyResolver()\n        self.num_joints = num_joints\n        self.joint_angles = np.zeros(num_joints)\n        \n    def control_step(self, desired_velocity, secondary_tasks=None):\n        """Control step with redundancy resolution"""\n        # Calculate Jacobian (simplified for example)\n        J = self.calculate_jacobian(self.joint_angles)\n        \n        # Resolve redundancy\n        q_dot = self.resolver.resolve_redundancy(\n            J, desired_velocity, secondary_tasks\n        )\n        \n        # Update joint angles\n        self.joint_angles += q_dot * 0.01  # 10ms timestep\n        \n        return q_dot\n    \n    def calculate_jacobian(self, q):\n        """Calculate simplified Jacobian for humanoid robot"""\n        # This is a simplified example\n        # Real implementation would depend on specific robot configuration\n        J = np.random.randn(6, self.num_joints)  # 6 task space, n joint space\n        return J\n\n# Example usage\ncontroller = HumanoidRedundancyController(num_joints=12)\n\n# Simulate control with redundancy resolution\ndesired_velocity = np.array([0.1, 0.0, 0.0, 0.0, 0.0, 0.0])  # Move forward\n\n# Secondary task: joint limit avoidance\nsecondary_task = controller.resolver.joint_limit_avoidance(\n    controller.joint_angles, np.zeros(12)\n)\n\n# Control step\nq_dot = controller.control_step(desired_velocity, secondary_task)\n\nprint(f"Joint velocities: {q_dot}")\nprint(f"Maximum joint velocity: {np.max(np.abs(q_dot)):.4f} rad/s")\n'})}),"\n",(0,s.jsx)(e.h2,{id:"task-space-analysis",children:"Task Space Analysis"}),"\n",(0,s.jsx)(e.h3,{id:"task-space-requirements",children:"Task Space Requirements"}),"\n",(0,s.jsx)(e.p,{children:"Different tasks require different DOF and workspace characteristics:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Locomotion Tasks"}),": Bipedal walking and running"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Minimum 6 DOF per leg (3 hip, 1 knee, 2 ankle)"}),"\n",(0,s.jsx)(e.li,{children:"Additional DOF for torso and arms"}),"\n",(0,s.jsx)(e.li,{children:"Focus on stability and energy efficiency"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Manipulation Tasks"}),": Object handling and tool use"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Minimum 6 DOF per arm (3 shoulder, 1 elbow, 2 wrist)"}),"\n",(0,s.jsx)(e.li,{children:"Additional DOF for hand and fingers"}),"\n",(0,s.jsx)(e.li,{children:"Focus on precision and dexterity"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Interaction Tasks"}),": Human-robot interaction"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Emphasis on safe and natural movement"}),"\n",(0,s.jsx)(e.li,{children:"Compliant control requirements"}),"\n",(0,s.jsx)(e.li,{children:"Social gesture capabilities"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"workspace-optimization",children:"Workspace Optimization"}),"\n",(0,s.jsx)(e.p,{children:"Optimizing workspace for specific tasks:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Reach Optimization"}),": Maximize useful workspace"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Link length optimization"}),"\n",(0,s.jsx)(e.li,{children:"Joint range optimization"}),"\n",(0,s.jsx)(e.li,{children:"Base positioning strategies"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Manipulability Optimization"}),": Maximize dexterity"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Joint configuration optimization"}),"\n",(0,s.jsx)(e.li,{children:"Singularity avoidance"}),"\n",(0,s.jsx)(e.li,{children:"Performance index maximization"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Energy Optimization"}),": Minimize power consumption"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Gravity compensation"}),"\n",(0,s.jsx)(e.li,{children:"Efficient trajectory planning"}),"\n",(0,s.jsx)(e.li,{children:"Regenerative braking"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"practical-design-examples",children:"Practical Design Examples"}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-arm-configuration",children:"Humanoid Arm Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Typical humanoid arm configuration:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Shoulder"}),": 3 DOF (spherical joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Flexion/extension: Forward/backward movement"}),"\n",(0,s.jsx)(e.li,{children:"Abduction/adduction: Side-to-side movement"}),"\n",(0,s.jsx)(e.li,{children:"Internal/external rotation: Arm rotation"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Elbow"}),": 1 DOF (revolute joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Flexion/extension: Bending arm"}),"\n",(0,s.jsx)(e.li,{children:"Critical for reach adjustment"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Wrist"}),": 2-3 DOF (universal or spherical joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Flexion/extension: Wrist bending"}),"\n",(0,s.jsx)(e.li,{children:"Radial/ulnar deviation: Side-to-side movement"}),"\n",(0,s.jsx)(e.li,{children:"Pronation/supination: Forearm rotation"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"humanoid-leg-configuration",children:"Humanoid Leg Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Typical humanoid leg configuration:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Hip"}),": 3 DOF (spherical joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Flexion/extension: Forward/backward leg movement"}),"\n",(0,s.jsx)(e.li,{children:"Abduction/adduction: Side-to-side leg movement"}),"\n",(0,s.jsx)(e.li,{children:"Internal/external rotation: Leg rotation"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Knee"}),": 1 DOF (revolute joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Flexion/extension: Leg bending"}),"\n",(0,s.jsx)(e.li,{children:"Critical for walking and balance"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Ankle"}),": 2-3 DOF (universal or spherical joint)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Dorsiflexion/plantarflexion: Foot up/down"}),"\n",(0,s.jsx)(e.li,{children:"Inversion/eversion: Foot tilting"}),"\n",(0,s.jsx)(e.li,{children:"Critical for balance and adaptation"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsx)(e.h3,{id:"exercise-1-dof-analysis",children:"Exercise 1: DOF Analysis"}),"\n",(0,s.jsx)(e.p,{children:"Analyze DOF for different robot configurations:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"6-DOF industrial arm"}),"\n",(0,s.jsx)(e.li,{children:"7-DOF redundant arm"}),"\n",(0,s.jsx)(e.li,{children:"Humanoid robot with 25 DOF"}),"\n",(0,s.jsx)(e.li,{children:"Compare mobility and redundancy"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-2-workspace-calculation",children:"Exercise 2: Workspace Calculation"}),"\n",(0,s.jsx)(e.p,{children:"Calculate and visualize workspace for:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"2-DOF planar arm"}),"\n",(0,s.jsx)(e.li,{children:"3-DOF spatial arm"}),"\n",(0,s.jsx)(e.li,{children:"6-DOF humanoid arm"}),"\n",(0,s.jsx)(e.li,{children:"Analyze manipulability distribution"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-3-redundancy-resolution",children:"Exercise 3: Redundancy Resolution"}),"\n",(0,s.jsx)(e.p,{children:"Implement redundancy resolution algorithms:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Weighted pseudoinverse method"}),"\n",(0,s.jsx)(e.li,{children:"Damped least squares method"}),"\n",(0,s.jsx)(e.li,{children:"Task prioritization approach"}),"\n",(0,s.jsx)(e.li,{children:"Compare performance and characteristics"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-4-optimization-problem",children:"Exercise 4: Optimization Problem"}),"\n",(0,s.jsx)(e.p,{children:"Optimize robot configuration for specific task:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Define task requirements and constraints"}),"\n",(0,s.jsx)(e.li,{children:"Implement optimization algorithm"}),"\n",(0,s.jsx)(e.li,{children:"Analyze trade-offs between different objectives"}),"\n",(0,s.jsx)(e.li,{children:"Validate optimal configuration"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"Degrees of freedom analysis is fundamental to humanoid robot design, determining mobility, manipulation capabilities, and control complexity. Understanding kinematic chains, workspace characteristics, and redundancy resolution enables engineers to design robots that can effectively perform human-like tasks."}),"\n",(0,s.jsx)(e.p,{children:"Key concepts include Gr\xfcbler's equation for DOF calculation, workspace analysis for reachability assessment, redundancy resolution for handling extra DOF, and task space optimization for specific applications. The balance between complexity and functionality determines robot performance and practicality."}),"\n",(0,s.jsx)(e.p,{children:"As humanoid robots become more sophisticated, DOF analysis continues to evolve, incorporating soft robotics, continuum mechanisms, and bio-inspired designs. The future of humanoid robotics lies in optimizing DOF not just for capability, but for efficiency, safety, and human-like naturalness of movement."}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.p,{children:['[1] Siciliano, B. and Khatib, O. "Springer Handbook of Robotics", 2nd Edition, Springer, 2021. ',(0,s.jsx)(e.a,{href:"https://doi.org/10.1007/978-3-030-90205-3",children:"https://doi.org/10.1007/978-3-030-90205-3"})]}),"\n",(0,s.jsxs)(e.p,{children:['[2] Craig, J.J. "Introduction to Robotics: Mechanics and Control", 4th Edition, Pearson, 2022. ',(0,s.jsx)(e.a,{href:"https://doi.org/10.1016/B978-0-12-818236-5.00009-8",children:"https://doi.org/10.1016/B978-0-12-818236-5.00009-8"})]}),"\n",(0,s.jsxs)(e.p,{children:['[3] Angeles, J. "Fundamentals of Robotic Mechanical Systems", 4th Edition, Springer, 2023. ',(0,s.jsx)(e.a,{href:"https://doi.org/10.1007/978-3-031-04839-9",children:"https://doi.org/10.1007/978-3-031-04839-9"})]}),"\n",(0,s.jsxs)(e.p,{children:['[4] Nakamura, Y. "Advanced Robotics: Redundancy and Optimization", Addison-Wesley, 2022. ',(0,s.jsx)(e.a,{href:"https://doi.org/10.1002/9781119456789",children:"https://doi.org/10.1002/9781119456789"})]}),"\n",(0,s.jsxs)(e.p,{children:['[5] IEEE Robotics and Automation Society, "Kinematic Modeling Standards", 2024. ',(0,s.jsx)(e.a,{href:"https://www.ieee-ras.org/standards",children:"https://www.ieee-ras.org/standards"})]})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>l});var a=i(6540);const s={},o=a.createContext(s);function t(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:t(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);