"use strict";(globalThis.webpackChunkphysical_and_humanoid_robotics_book=globalThis.webpackChunkphysical_and_humanoid_robotics_book||[]).push([[968],{6344:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"physical-fundamentals/power-systems","title":"Power Systems and Energy Management","description":"Comprehensive guide to power systems for humanoid robots, covering batteries, power electronics, energy management, and thermal considerations","source":"@site/docs/02-physical-fundamentals/04-power-systems.mdx","sourceDirName":"02-physical-fundamentals","slug":"/physical-fundamentals/power-systems","permalink":"/Robotics-Book/docs/physical-fundamentals/power-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02-physical-fundamentals/04-power-systems.mdx","tags":[{"inline":true,"label":"power-systems","permalink":"/Robotics-Book/docs/tags/power-systems"},{"inline":true,"label":"energy-management","permalink":"/Robotics-Book/docs/tags/energy-management"},{"inline":true,"label":"robotics","permalink":"/Robotics-Book/docs/tags/robotics"},{"inline":true,"label":"physical-fundamentals","permalink":"/Robotics-Book/docs/tags/physical-fundamentals"}],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Power Systems and Energy Management","sidebar_label":"Power Systems and Energy Management","description":"Comprehensive guide to power systems for humanoid robots, covering batteries, power electronics, energy management, and thermal considerations","hide_table_of_contents":false,"authors":["Robotics Book Team"],"tags":["power-systems","energy-management","robotics","physical-fundamentals"],"reading_time":22,"difficulty":"intermediate","prerequisites":["01-kinematics-dynamics","02-actuators-motors"],"learning_objectives":["Understand power requirements for humanoid robots","Compare different battery technologies and their applications","Design power electronics for robotic systems","Implement energy management strategies","Analyze thermal management for power systems"]},"sidebar":"bookSidebar","previous":{"title":"Sensors and Perception","permalink":"/Robotics-Book/docs/physical-fundamentals/sensors"},"next":{"title":"Control Theory and Systems","permalink":"/Robotics-Book/docs/physical-fundamentals/control-theory"}}');var r=t(4848),s=t(8453);const o={title:"Power Systems and Energy Management",sidebar_label:"Power Systems and Energy Management",description:"Comprehensive guide to power systems for humanoid robots, covering batteries, power electronics, energy management, and thermal considerations",hide_table_of_contents:!1,authors:["Robotics Book Team"],tags:["power-systems","energy-management","robotics","physical-fundamentals"],reading_time:22,difficulty:"intermediate",prerequisites:["01-kinematics-dynamics","02-actuators-motors"],learning_objectives:["Understand power requirements for humanoid robots","Compare different battery technologies and their applications","Design power electronics for robotic systems","Implement energy management strategies","Analyze thermal management for power systems"]},a="Power Systems and Energy Management",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Power Requirements Analysis",id:"power-requirements-analysis",level:2},{value:"Power Consumption Breakdown",id:"power-consumption-breakdown",level:3},{value:"Power Profile Analysis",id:"power-profile-analysis",level:3},{value:"Battery Technologies",id:"battery-technologies",level:2},{value:"Lithium-Ion Batteries",id:"lithium-ion-batteries",level:3},{value:"Lithium-Polymer Batteries",id:"lithium-polymer-batteries",level:3},{value:"Emerging Battery Technologies",id:"emerging-battery-technologies",level:3},{value:"Battery Selection Criteria",id:"battery-selection-criteria",level:3},{value:"Power Electronics",id:"power-electronics",level:2},{value:"DC-DC Converters",id:"dc-dc-converters",level:3},{value:"Battery Management Systems (BMS)",id:"battery-management-systems-bms",level:3},{value:"Energy Management Strategies",id:"energy-management-strategies",level:2},{value:"Power Optimization Techniques",id:"power-optimization-techniques",level:3},{value:"Energy-Aware Control",id:"energy-aware-control",level:3},{value:"Thermal Management",id:"thermal-management",level:2},{value:"Heat Generation Sources",id:"heat-generation-sources",level:3},{value:"Cooling Strategies",id:"cooling-strategies",level:3},{value:"Thermal Monitoring and Control",id:"thermal-monitoring-and-control",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Battery Pack Design",id:"battery-pack-design",level:3},{value:"Power Distribution Architecture",id:"power-distribution-architecture",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Power Budget Analysis",id:"exercise-1-power-budget-analysis",level:3},{value:"Exercise 2: Battery Selection",id:"exercise-2-battery-selection",level:3},{value:"Exercise 3: Energy Optimization",id:"exercise-3-energy-optimization",level:3},{value:"Exercise 4: Thermal System Design",id:"exercise-4-thermal-system-design",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"power-systems-and-energy-management",children:"Power Systems and Energy Management"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Understand power requirements for humanoid robots"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Compare different battery technologies and their applications"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Design power electronics for robotic systems"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement energy management strategies"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Analyze thermal management for power systems"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"Power systems are the lifeblood of humanoid robots, providing the energy needed for actuators, sensors, computers, and communication systems. Unlike industrial robots that can be tethered to power grids, humanoid robots require mobile, self-contained power solutions that can sustain operation for extended periods while meeting demanding power requirements for locomotion and manipulation."}),"\n",(0,r.jsx)(n.p,{children:"The challenge of powering humanoid robots is multifaceted: they need high power density for dynamic movements, high energy density for long operation times, sophisticated power management for efficiency, and robust thermal management to prevent overheating. This module explores the complete power system architecture, from energy storage to power conversion and management strategies."}),"\n",(0,r.jsx)(n.h2,{id:"power-requirements-analysis",children:"Power Requirements Analysis"}),"\n",(0,r.jsx)(n.h3,{id:"power-consumption-breakdown",children:"Power Consumption Breakdown"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots consume power through multiple subsystems, each with distinct characteristics:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Actuator Power"}),": The largest power consumer, typically 60-80% of total consumption. Power requirements vary dramatically based on activity:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Standing: 50-100W"}),"\n",(0,r.jsx)(n.li,{children:"Walking: 200-500W"}),"\n",(0,r.jsx)(n.li,{children:"Running/Jumping: 1000-2000W peak"}),"\n",(0,r.jsx)(n.li,{children:"Lifting heavy objects: 500-1500W"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Computing Power"}),": 50-200W for perception, planning, and control systems"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low-power processors for basic control: 10-30W"}),"\n",(0,r.jsx)(n.li,{children:"GPU for vision processing: 100-150W"}),"\n",(0,r.jsx)(n.li,{children:"Additional processors for AI/ML: 20-50W"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sensor Systems"}),": 10-50W for cameras, LiDAR, IMUs, and other sensors"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Vision cameras: 5-15W"}),"\n",(0,r.jsx)(n.li,{children:"LiDAR systems: 10-30W"}),"\n",(0,r.jsx)(n.li,{children:"IMUs and encoders: 1-5W"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Communication"}),": 5-20W for wireless communication and networking"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"WiFi/Bluetooth: 2-5W"}),"\n",(0,r.jsx)(n.li,{children:"5G/cellular: 5-15W"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"power-profile-analysis",children:"Power Profile Analysis"}),"\n",(0,r.jsx)(n.p,{children:"Understanding power consumption patterns is crucial for system design:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nclass PowerAnalyzer:\n    \"\"\"Power consumption analysis for humanoid robots\"\"\"\n    \n    def __init__(self):\n        self.subsystems = {\n            'actuators': {'base_power': 50, 'peak_multiplier': 20},\n            'computing': {'base_power': 100, 'peak_multiplier': 1.5},\n            'sensors': {'base_power': 20, 'peak_multiplier': 2},\n            'communication': {'base_power': 10, 'peak_multiplier': 2}\n        }\n        \n    def calculate_power_profile(self, activity_sequence, duration=300):\n        \"\"\"Calculate power consumption over time\"\"\"\n        time_steps = np.linspace(0, duration, int(duration * 10))  # 10Hz sampling\n        power_profile = {subsystem: [] for subsystem in self.subsystems}\n        \n        for t in time_steps:\n            # Determine current activity\n            activity = self.get_activity_at_time(activity_sequence, t)\n            \n            for subsystem, config in self.subsystems.items():\n                base_power = config['base_power']\n                peak_multiplier = config['peak_multiplier']\n                \n                # Calculate power based on activity\n                if subsystem == 'actuators':\n                    power = self.calculate_actuator_power(activity, base_power, peak_multiplier)\n                elif subsystem == 'computing':\n                    power = self.calculate_computing_power(activity, base_power, peak_multiplier)\n                elif subsystem == 'sensors':\n                    power = self.calculate_sensor_power(activity, base_power, peak_multiplier)\n                else:  # communication\n                    power = self.calculate_communication_power(activity, base_power, peak_multiplier)\n                \n                power_profile[subsystem].append(power)\n        \n        return time_steps, power_profile\n    \n    def get_activity_at_time(self, activity_sequence, current_time):\n        \"\"\"Determine activity at given time\"\"\"\n        for activity, start_time, end_time in activity_sequence:\n            if start_time <= current_time < end_time:\n                return activity\n        return 'idle'\n    \n    def calculate_actuator_power(self, activity, base_power, peak_multiplier):\n        \"\"\"Calculate actuator power based on activity\"\"\"\n        power_multipliers = {\n            'idle': 0.2,\n            'standing': 1.0,\n            'walking': 4.0,\n            'running': 15.0,\n            'jumping': 20.0,\n            'lifting': 10.0\n        }\n        return base_power * power_multipliers.get(activity, 1.0)\n    \n    def calculate_computing_power(self, activity, base_power, peak_multiplier):\n        \"\"\"Calculate computing power based on activity\"\"\"\n        power_multipliers = {\n            'idle': 0.5,\n            'standing': 0.8,\n            'walking': 1.0,\n            'running': 1.3,\n            'jumping': 1.5,\n            'lifting': 1.2\n        }\n        return base_power * power_multipliers.get(activity, 1.0)\n    \n    def calculate_sensor_power(self, activity, base_power, peak_multiplier):\n        \"\"\"Calculate sensor power based on activity\"\"\"\n        power_multipliers = {\n            'idle': 0.5,\n            'standing': 1.0,\n            'walking': 1.5,\n            'running': 2.0,\n            'jumping': 2.0,\n            'lifting': 1.2\n        }\n        return base_power * power_multipliers.get(activity, 1.0)\n    \n    def calculate_communication_power(self, activity, base_power, peak_multiplier):\n        \"\"\"Calculate communication power based on activity\"\"\"\n        power_multipliers = {\n            'idle': 0.3,\n            'standing': 0.5,\n            'walking': 1.0,\n            'running': 1.5,\n            'jumping': 1.0,\n            'lifting': 0.8\n        }\n        return base_power * power_multipliers.get(activity, 1.0)\n    \n    def analyze_energy_consumption(self, time_steps, power_profile):\n        \"\"\"Analyze total energy consumption\"\"\"\n        total_power = []\n        for i in range(len(time_steps)):\n            total = sum(power_profile[subsystem][i] for subsystem in power_profile)\n            total_power.append(total)\n        \n        # Calculate energy consumption (Wh)\n        dt = time_steps[1] - time_steps[0]\n        total_energy = np.trapz(total_power, time_steps) / 3600  # Convert to Wh\n        \n        # Calculate statistics\n        avg_power = np.mean(total_power)\n        peak_power = np.max(total_power)\n        \n        return {\n            'total_energy': total_energy,\n            'average_power': avg_power,\n            'peak_power': peak_power,\n            'power_profile': total_power\n        }\n\n# Example usage\nanalyzer = PowerAnalyzer()\n\n# Define activity sequence (activity, start_time, end_time)\nactivities = [\n    ('standing', 0, 60),\n    ('walking', 60, 180),\n    ('running', 180, 210),\n    ('lifting', 210, 270),\n    ('standing', 270, 300)\n]\n\ntime_steps, power_profile = analyzer.calculate_power_profile(activities)\nanalysis = analyzer.analyze_energy_consumption(time_steps, power_profile)\n\nprint(f\"Total energy consumption: {analysis['total_energy']:.2f} Wh\")\nprint(f\"Average power: {analysis['average_power']:.2f} W\")\nprint(f\"Peak power: {analysis['peak_power']:.2f} W\")\n\n# Plot power profile\nplt.figure(figsize=(12, 6))\nplt.plot(time_steps, analysis['power_profile'], 'b-', linewidth=2)\nplt.xlabel('Time (s)')\nplt.ylabel('Power (W)')\nplt.title('Humanoid Robot Power Consumption Profile')\nplt.grid(True)\nplt.show()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"battery-technologies",children:"Battery Technologies"}),"\n",(0,r.jsx)(n.h3,{id:"lithium-ion-batteries",children:"Lithium-Ion Batteries"}),"\n",(0,r.jsx)(n.p,{children:"Lithium-ion batteries are the most common energy storage solution for humanoid robots due to their high energy density and mature technology."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Chemistry Variants"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LiCoO2 (LCO)"}),": High energy density, common in consumer electronics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LiFePO4 (LFP)"}),": Excellent safety, long cycle life, lower energy density"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NMC (Nickel-Manganese-Cobalt)"}),": Balanced performance, widely used in EVs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NCA (Nickel-Cobalt-Aluminum)"}),": High energy density, used in Tesla vehicles"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"High energy density (150-250 Wh/kg)"}),"\n",(0,r.jsx)(n.li,{children:"High power density (500-2000 W/kg)"}),"\n",(0,r.jsx)(n.li,{children:"Low self-discharge rate"}),"\n",(0,r.jsx)(n.li,{children:"No memory effect"}),"\n",(0,r.jsx)(n.li,{children:"Wide operating temperature range"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Safety concerns (thermal runaway)"}),"\n",(0,r.jsx)(n.li,{children:"Limited cycle life (500-2000 cycles)"}),"\n",(0,r.jsx)(n.li,{children:"Performance degradation at low temperatures"}),"\n",(0,r.jsx)(n.li,{children:"Complex battery management required"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lithium-polymer-batteries",children:"Lithium-Polymer Batteries"}),"\n",(0,r.jsx)(n.p,{children:"Lithium-polymer batteries use solid polymer electrolytes instead of liquid electrolytes, offering design flexibility."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Flexible form factors"}),"\n",(0,r.jsx)(n.li,{children:"Lightweight construction"}),"\n",(0,r.jsx)(n.li,{children:"Improved safety over liquid Li-ion"}),"\n",(0,r.jsx)(n.li,{children:"Higher discharge rates"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lower energy density than Li-ion"}),"\n",(0,r.jsx)(n.li,{children:"Higher cost"}),"\n",(0,r.jsx)(n.li,{children:"Limited cycle life"}),"\n",(0,r.jsx)(n.li,{children:"Sensitive to overcharging"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"emerging-battery-technologies",children:"Emerging Battery Technologies"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Solid-State Batteries"}),": Replace liquid electrolytes with solid materials, offering:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Higher energy density (300-500 Wh/kg)"}),"\n",(0,r.jsx)(n.li,{children:"Enhanced safety"}),"\n",(0,r.jsx)(n.li,{children:"Longer cycle life"}),"\n",(0,r.jsx)(n.li,{children:"Wider temperature range"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lithium-Sulfur Batteries"}),": Promise very high theoretical energy density (2500 Wh/kg) but face challenges with cycle life and efficiency."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graphene Batteries"}),": Use graphene materials to improve conductivity and charge rates."]}),"\n",(0,r.jsx)(n.h3,{id:"battery-selection-criteria",children:"Battery Selection Criteria"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Energy Density"}),": Determines operating time per unit weight\n",(0,r.jsx)(n.strong,{children:"Power Density"}),": Determines ability to deliver high current for dynamic movements\n",(0,r.jsx)(n.strong,{children:"Cycle Life"}),": Determines battery replacement frequency\n",(0,r.jsx)(n.strong,{children:"Safety"}),": Critical for robots operating near humans\n",(0,r.jsx)(n.strong,{children:"Cost"}),": Impacts overall system economics\n",(0,r.jsx)(n.strong,{children:"Temperature Performance"}),": Affects operation in different environments"]}),"\n",(0,r.jsx)(n.h2,{id:"power-electronics",children:"Power Electronics"}),"\n",(0,r.jsx)(n.h3,{id:"dc-dc-converters",children:"DC-DC Converters"}),"\n",(0,r.jsx)(n.p,{children:"DC-DC converters transform voltage levels to match different subsystem requirements:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Buck Converters"}),": Step down voltage (e.g., 48V to 12V for sensors)\n",(0,r.jsx)(n.strong,{children:"Boost Converters"}),": Step up voltage (e.g., 12V to 48V for actuators)\n",(0,r.jsx)(n.strong,{children:"Buck-Boost Converters"}),": Can step up or down voltage\n",(0,r.jsx)(n.strong,{children:"Isolated Converters"}),": Provide electrical isolation between input and output"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class PowerConverter:\n    \"\"\"DC-DC converter design and analysis\"\"\"\n    \n    def __init__(self, input_voltage, output_voltage, efficiency=0.95):\n        self.input_voltage = input_voltage\n        self.output_voltage = output_voltage\n        self.efficiency = efficiency\n        \n    def calculate_buck_converter(self, load_current, switching_frequency=100000):\n        \"\"\"Design buck converter parameters\"\"\"\n        # Duty cycle\n        duty_cycle = self.output_voltage / self.input_voltage\n        \n        # Inductor value (assuming 30% current ripple)\n        ripple_ratio = 0.3\n        inductance = (self.input_voltage - self.output_voltage) * duty_cycle / \\\n                    (ripple_ratio * load_current * switching_frequency)\n        \n        # Output capacitor (assuming 1% voltage ripple)\n        voltage_ripple = 0.01 * self.output_voltage\n        capacitance = load_current * duty_cycle / \\\n                     (switching_frequency * voltage_ripple)\n        \n        # Input and output power\n        output_power = self.output_voltage * load_current\n        input_power = output_power / self.efficiency\n        input_current = input_power / self.input_voltage\n        \n        return {\n            'duty_cycle': duty_cycle,\n            'inductance': inductance,\n            'capacitance': capacitance,\n            'input_current': input_current,\n            'output_power': output_power,\n            'input_power': input_power,\n            'power_loss': input_power - output_power\n        }\n    \n    def calculate_boost_converter(self, load_current, switching_frequency=100000):\n        \"\"\"Design boost converter parameters\"\"\"\n        # Duty cycle\n        duty_cycle = 1 - (self.input_voltage / self.output_voltage)\n        \n        # Inductor value (assuming 30% current ripple)\n        ripple_ratio = 0.3\n        input_current = load_current * self.output_voltage / self.input_voltage\n        inductance = self.input_voltage * duty_cycle / \\\n                    (ripple_ratio * input_current * switching_frequency)\n        \n        # Output capacitor (assuming 1% voltage ripple)\n        voltage_ripple = 0.01 * self.output_voltage\n        capacitance = load_current * duty_cycle / \\\n                     (switching_frequency * voltage_ripple)\n        \n        # Power calculations\n        output_power = self.output_voltage * load_current\n        input_power = output_power / self.efficiency\n        \n        return {\n            'duty_cycle': duty_cycle,\n            'inductance': inductance,\n            'capacitance': capacitance,\n            'input_current': input_current,\n            'output_power': output_power,\n            'input_power': input_power,\n            'power_loss': input_power - output_power\n        }\n\n# Example: Design power distribution for humanoid robot\nclass RobotPowerSystem:\n    def __init__(self, battery_voltage=48.0):\n        self.battery_voltage = battery_voltage\n        self.subsystems = {\n            'actuators': {'voltage': 48.0, 'max_current': 50.0},\n            'computing': {'voltage': 12.0, 'max_current': 15.0},\n            'sensors': {'voltage': 5.0, 'max_current': 5.0},\n            'communication': {'voltage': 3.3, 'max_current': 3.0}\n        }\n        \n    def design_power_distribution(self):\n        \"\"\"Design power distribution system\"\"\"\n        converters = {}\n        \n        for subsystem, requirements in self.subsystems.items():\n            if requirements['voltage'] != self.battery_voltage:\n                if requirements['voltage'] < self.battery_voltage:\n                    # Buck converter\n                    converter = PowerConverter(\n                        self.battery_voltage, \n                        requirements['voltage']\n                    )\n                    design = converter.calculate_buck_converter(\n                        requirements['max_current']\n                    )\n                else:\n                    # Boost converter\n                    converter = PowerConverter(\n                        self.battery_voltage,\n                        requirements['voltage']\n                    )\n                    design = converter.calculate_boost_converter(\n                        requirements['max_current']\n                    )\n                \n                converters[subsystem] = design\n            else:\n                # Direct connection\n                converters[subsystem] = {\n                    'type': 'direct',\n                    'max_power': requirements['voltage'] * requirements['max_current']\n                }\n        \n        return converters\n    \n    def calculate_total_power_budget(self):\n        \"\"\"Calculate total power requirements\"\"\"\n        total_power = 0\n        for subsystem, requirements in self.subsystems.items():\n            total_power += requirements['voltage'] * requirements['max_current']\n        \n        return total_power\n\n# Usage example\npower_system = RobotPowerSystem(battery_voltage=48.0)\nconverters = power_system.design_power_distribution()\ntotal_budget = power_system.calculate_total_power_budget()\n\nprint(f\"Total power budget: {total_budget:.2f} W\")\nprint(\"\\nPower converter designs:\")\nfor subsystem, design in converters.items():\n    print(f\"\\n{subsystem}:\")\n    if design.get('type') == 'direct':\n        print(f\"  Direct connection, max power: {design['max_power']:.2f} W\")\n    else:\n        print(f\"  Duty cycle: {design['duty_cycle']:.3f}\")\n        print(f\"  Inductance: {design['inductance']*1e6:.2f} \xb5H\")\n        print(f\"  Capacitance: {design['capacitance']*1e6:.2f} \xb5F\")\n        print(f\"  Power loss: {design['power_loss']:.2f} W\")\n"})}),"\n",(0,r.jsx)(n.h3,{id:"battery-management-systems-bms",children:"Battery Management Systems (BMS)"}),"\n",(0,r.jsx)(n.p,{children:"BMS is critical for safety, performance, and longevity of battery packs:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cell Monitoring"}),": Voltage, temperature, and current monitoring for each cell\n",(0,r.jsx)(n.strong,{children:"State of Charge (SOC) Estimation"}),": Accurate battery level indication\n",(0,r.jsx)(n.strong,{children:"State of Health (SOH) Monitoring"}),": Battery degradation tracking\n",(0,r.jsx)(n.strong,{children:"Cell Balancing"}),": Ensuring all cells charge/discharge evenly\n",(0,r.jsx)(n.strong,{children:"Protection"}),": Over-voltage, under-voltage, over-current, and thermal protection\n",(0,r.jsx)(n.strong,{children:"Communication"}),": Interface with robot control system"]}),"\n",(0,r.jsx)(n.h2,{id:"energy-management-strategies",children:"Energy Management Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"power-optimization-techniques",children:"Power Optimization Techniques"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Power Management"}),": Adjust power consumption based on activity level"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduce sensor sampling rates during low activity"}),"\n",(0,r.jsx)(n.li,{children:"Scale computing performance based on task requirements"}),"\n",(0,r.jsx)(n.li,{children:"Optimize actuator control for efficiency"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Regenerative Systems"}),": Recover energy during deceleration and braking"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Regenerative braking in locomotion"}),"\n",(0,r.jsx)(n.li,{children:"Energy recovery from lowering heavy objects"}),"\n",(0,r.jsx)(n.li,{children:"Capacitive storage for peak power buffering"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sleep Modes"}),": Power down non-essential subsystems when not needed"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sensor sleep modes during stationary periods"}),"\n",(0,r.jsx)(n.li,{children:"Processor power gating for idle cores"}),"\n",(0,r.jsx)(n.li,{children:"Communication power cycling"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"energy-aware-control",children:"Energy-Aware Control"}),"\n",(0,r.jsx)(n.p,{children:"Control algorithms can significantly impact energy consumption:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class EnergyAwareController:\n    \"\"\"Energy-aware motion planning and control\"\"\"\n    \n    def __init__(self, robot_model):\n        self.robot_model = robot_model\n        self.energy_cost_weight = 0.1\n        \n    def calculate_energy_cost(self, trajectory):\n        \"\"\"Calculate energy cost for given trajectory\"\"\"\n        total_energy = 0\n        \n        for i in range(len(trajectory) - 1):\n            # Get joint positions and velocities\n            q = trajectory[i]['position']\n            q_dot = trajectory[i]['velocity']\n            q_ddot = trajectory[i]['acceleration']\n            \n            # Calculate required torques using inverse dynamics\n            tau = self.robot_model.inverse_dynamics(q, q_dot, q_ddot)\n            \n            # Calculate instantaneous power\n            power = np.sum(tau * q_dot)\n            \n            # Integrate over time step\n            dt = trajectory[i+1]['time'] - trajectory[i]['time']\n            total_energy += abs(power) * dt\n        \n        return total_energy\n    \n    def optimize_trajectory_energy(self, initial_trajectory):\n        \"\"\"Optimize trajectory for energy efficiency\"\"\"\n        optimized_trajectory = initial_trajectory.copy()\n        \n        # Apply smoothing to reduce high-frequency components\n        for joint in range(len(initial_trajectory[0]['position'])):\n            positions = [point['position'][joint] for point in initial_trajectory]\n            \n            # Apply low-pass filter\n            smoothed_positions = self.low_pass_filter(positions, cutoff=0.1)\n            \n            # Update trajectory\n            for i, point in enumerate(optimized_trajectory):\n                point['position'][joint] = smoothed_positions[i]\n        \n        # Recalculate velocities and accelerations\n        self.recalculate_derivatives(optimized_trajectory)\n        \n        return optimized_trajectory\n    \n    def low_pass_filter(self, data, cutoff=0.1, sampling_rate=100):\n        \"\"\"Apply low-pass filter to smooth data\"\"\"\n        from scipy import signal\n        nyquist = sampling_rate / 2\n        normal_cutoff = cutoff / nyquist\n        b, a = signal.butter(4, normal_cutoff, btype='low', analog=False)\n        return signal.filtfilt(b, a, data)\n    \n    def recalculate_derivatives(self, trajectory):\n        \"\"\"Recalculate velocities and accelerations\"\"\"\n        for i in range(len(trajectory)):\n            if i > 0:\n                dt = trajectory[i]['time'] - trajectory[i-1]['time']\n                trajectory[i]['velocity'] = (\n                    trajectory[i]['position'] - trajectory[i-1]['position']\n                ) / dt\n            else:\n                trajectory[i]['velocity'] = np.zeros_like(trajectory[i]['position'])\n            \n            if i > 1:\n                dt = trajectory[i]['time'] - trajectory[i-1]['time']\n                trajectory[i]['acceleration'] = (\n                    trajectory[i]['velocity'] - trajectory[i-1]['velocity']\n                ) / dt\n            else:\n                trajectory[i]['acceleration'] = np.zeros_like(trajectory[i]['position'])\n\n# Example usage\nclass SimpleRobotModel:\n    def inverse_dynamics(self, q, q_dot, q_ddot):\n        \"\"\"Simple inverse dynamics model\"\"\"\n        # Simplified calculation - in practice would use full dynamics\n        inertia = np.array([2.0, 1.5, 1.0, 0.5, 0.3, 0.2])  # Joint inertias\n        friction = np.array([0.1, 0.08, 0.06, 0.04, 0.02, 0.01])  # Friction coefficients\n        \n        tau = inertia * q_ddot + friction * q_dot\n        return tau\n\n# Create sample trajectory\ntrajectory = []\nfor i in range(100):\n    trajectory.append({\n        'time': i * 0.01,\n        'position': np.array([0.1 * np.sin(0.1 * i), 0.05 * np.cos(0.1 * i), 0, 0, 0, 0]),\n        'velocity': np.zeros(6),\n        'acceleration': np.zeros(6)\n    })\n\n# Optimize for energy\nrobot_model = SimpleRobotModel()\ncontroller = EnergyAwareController(robot_model)\n\ninitial_energy = controller.calculate_energy_cost(trajectory)\noptimized_trajectory = controller.optimize_trajectory_energy(trajectory)\noptimized_energy = controller.calculate_energy_cost(optimized_trajectory)\n\nprint(f\"Initial energy consumption: {initial_energy:.2f} J\")\nprint(f\"Optimized energy consumption: {optimized_energy:.2f} J\")\nprint(f\"Energy savings: {(1 - optimized_energy/initial_energy)*100:.1f}%\")\n"})}),"\n",(0,r.jsx)(n.h2,{id:"thermal-management",children:"Thermal Management"}),"\n",(0,r.jsx)(n.h3,{id:"heat-generation-sources",children:"Heat Generation Sources"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Power Electronics"}),": Switching losses and conduction losses in converters\n",(0,r.jsx)(n.strong,{children:"Actuators"}),": Resistive heating in motor windings and friction losses\n",(0,r.jsx)(n.strong,{children:"Batteries"}),": Internal resistance heating during charge/discharge\n",(0,r.jsx)(n.strong,{children:"Computing"}),": Processor heat generation during computation"]}),"\n",(0,r.jsx)(n.h3,{id:"cooling-strategies",children:"Cooling Strategies"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Passive Cooling"}),": Heat sinks, heat pipes, and natural convection\n",(0,r.jsx)(n.strong,{children:"Active Cooling"}),": Fans, liquid cooling, and thermoelectric cooling\n",(0,r.jsx)(n.strong,{children:"Phase Change Materials"}),": Absorb heat during phase transitions\n",(0,r.jsx)(n.strong,{children:"Heat Distribution"}),": Spread heat across larger surface areas"]}),"\n",(0,r.jsx)(n.h3,{id:"thermal-monitoring-and-control",children:"Thermal Monitoring and Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ThermalManager:\n    \"\"\"Thermal management system for humanoid robots\"\"\"\n    \n    def __init__(self):\n        self.components = {\n            'battery': {'temp': 25.0, 'max_temp': 60.0, 'critical_temp': 70.0},\n            'actuators': {'temp': 30.0, 'max_temp': 80.0, 'critical_temp': 90.0},\n            'electronics': {'temp': 35.0, 'max_temp': 70.0, 'critical_temp': 85.0},\n            'processors': {'temp': 40.0, 'max_temp': 85.0, 'critical_temp': 95.0}\n        }\n        self.cooling_systems = {\n            'fans': {'status': False, 'power': 10.0},\n            'liquid_cooling': {'status': False, 'power': 50.0},\n            'thermal_throttling': {'status': False, 'reduction': 0.0}\n        }\n        \n    def update_temperatures(self, power_dissipation, ambient_temp=25.0):\n        \"\"\"Update component temperatures based on power dissipation\"\"\"\n        for component, power in power_dissipation.items():\n            if component in self.components:\n                # Simple thermal model: dT/dt = (P - h*A*(T - T_ambient)) / (m*c)\n                thermal_resistance = 0.5  # K/W (simplified)\n                thermal_capacitance = 100  # J/K (simplified)\n                \n                # Temperature rise due to power dissipation\n                temp_rise = power * thermal_resistance\n                \n                # Update temperature with exponential approach\n                target_temp = ambient_temp + temp_rise\n                current_temp = self.components[component]['temp']\n                \n                # Exponential smoothing (time constant = thermal_resistance * thermal_capacitance)\n                time_constant = thermal_resistance * thermal_capacitance\n                dt = 0.1  # 100ms update interval\n                alpha = dt / time_constant\n                \n                self.components[component]['temp'] = (\n                    current_temp + alpha * (target_temp - current_temp)\n                )\n    \n    def manage_cooling(self):\n        \"\"\"Manage cooling systems based on temperatures\"\"\"\n        max_temp = max(comp['temp'] for comp in self.components.values())\n        \n        # Turn on fans if any component exceeds 50\xb0C\n        if max_temp > 50.0:\n            self.cooling_systems['fans']['status'] = True\n        else:\n            self.cooling_systems['fans']['status'] = False\n        \n        # Turn on liquid cooling if any component exceeds 70\xb0C\n        if max_temp > 70.0:\n            self.cooling_systems['liquid_cooling']['status'] = True\n        else:\n            self.cooling_systems['liquid_cooling']['status'] = False\n        \n        # Apply thermal throttling if critical temperatures approached\n        critical_component = None\n        for name, comp in self.components.items():\n            if comp['temp'] > comp['critical_temp'] - 5.0:\n                critical_component = name\n                break\n        \n        if critical_component:\n            # Reduce performance to lower temperature\n            temp_excess = self.components[critical_component]['temp'] - (self.components[critical_component]['critical_temp'] - 5.0)\n            reduction = min(0.5, temp_excess / 10.0)  # Up to 50% reduction\n            \n            self.cooling_systems['thermal_throttling']['status'] = True\n            self.cooling_systems['thermal_throttling']['reduction'] = reduction\n        else:\n            self.cooling_systems['thermal_throttling']['status'] = False\n            self.cooling_systems['thermal_throttling']['reduction'] = 0.0\n    \n    def get_cooling_power(self):\n        \"\"\"Calculate total cooling power consumption\"\"\"\n        total_power = 0\n        \n        for system, config in self.cooling_systems.items():\n            if config['status']:\n                if system == 'thermal_throttling':\n                    # Throttling saves power rather than consuming it\n                    total_power -= config['reduction'] * 100  # Assume 100W base load\n                else:\n                    total_power += config['power']\n        \n        return total_power\n    \n    def check_thermal_safety(self):\n        \"\"\"Check for thermal safety issues\"\"\"\n        warnings = []\n        critical_alerts = []\n        \n        for name, comp in self.components.items():\n            if comp['temp'] > comp['max_temp']:\n                warnings.append(f\"{name} temperature ({comp['temp']:.1f}\xb0C) exceeds maximum\")\n            \n            if comp['temp'] > comp['critical_temp']:\n                critical_alerts.append(f\"{name} critical temperature ({comp['temp']:.1f}\xb0C)\")\n        \n        return warnings, critical_alerts\n\n# Example usage\nthermal_manager = ThermalManager()\n\n# Simulate power dissipation during different activities\nactivities = [\n    {'name': 'idle', 'duration': 60, 'power': {'battery': 5, 'actuators': 10, 'electronics': 20, 'processors': 30}},\n    {'name': 'walking', 'duration': 120, 'power': {'battery': 15, 'actuators': 100, 'electronics': 25, 'processors': 40}},\n    {'name': 'running', 'duration': 60, 'power': {'battery': 25, 'actuators': 300, 'electronics': 30, 'processors': 50}},\n]\n\nfor activity in activities:\n    print(f\"\\nSimulating {activity['name']} for {activity['duration']} seconds...\")\n    \n    for step in range(activity['duration']):\n        thermal_manager.update_temperatures(activity['power'])\n        thermal_manager.manage_cooling()\n        \n        if step % 30 == 0:  # Report every 30 seconds\n            warnings, critical = thermal_manager.check_thermal_safety()\n            cooling_power = thermal_manager.get_cooling_power()\n            \n            print(f\"  Time {step}s: Max temp = {max(comp['temp'] for comp in thermal_manager.components.values()):.1f}\xb0C\")\n            print(f\"  Cooling power: {cooling_power:.1f}W\")\n            \n            if warnings:\n                print(f\"  Warnings: {', '.join(warnings)}\")\n            if critical:\n                print(f\"  CRITICAL: {', '.join(critical)}\")\n"})}),"\n",(0,r.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,r.jsx)(n.h3,{id:"battery-pack-design",children:"Battery Pack Design"}),"\n",(0,r.jsx)(n.p,{children:"Designing a battery pack for a humanoid robot involves multiple considerations:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Voltage Requirements"}),": Match actuator voltage requirements (typically 48V for high-power actuators)\n",(0,r.jsx)(n.strong,{children:"Capacity Requirements"}),": Determine based on desired operating time and power consumption\n",(0,r.jsx)(n.strong,{children:"Configuration"}),": Series connections for voltage, parallel for capacity\n",(0,r.jsx)(n.strong,{children:"Safety Features"}),": Fuses, circuit breakers, and thermal protection\n",(0,r.jsx)(n.strong,{children:"Monitoring"}),": BMS integration for cell monitoring and balancing"]}),"\n",(0,r.jsx)(n.h3,{id:"power-distribution-architecture",children:"Power Distribution Architecture"}),"\n",(0,r.jsx)(n.p,{children:"A typical humanoid robot power distribution system includes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Main Battery Pack"}),": High-voltage, high-capacity battery pack"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Main DC-DC Converter"}),": Steps down to intermediate voltage (24V or 12V)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secondary Converters"}),": Provide specific voltages for different subsystems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protection Circuits"}),": Over-current, over-voltage, and reverse polarity protection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitoring System"}),": Real-time power monitoring and fault detection"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsx)(n.h3,{id:"exercise-1-power-budget-analysis",children:"Exercise 1: Power Budget Analysis"}),"\n",(0,r.jsx)(n.p,{children:"Calculate the power budget for a humanoid robot with the following specifications:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"6 DOF legs (50W per joint during walking)"}),"\n",(0,r.jsx)(n.li,{children:"6 DOF arms (20W per joint during manipulation)"}),"\n",(0,r.jsx)(n.li,{children:"Vision system (100W)"}),"\n",(0,r.jsx)(n.li,{children:"Control computer (150W)"}),"\n",(0,r.jsx)(n.li,{children:"Sensor suite (50W)"}),"\n",(0,r.jsx)(n.li,{children:"Communication system (20W)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Determine battery capacity needed for 4 hours of operation with 20% safety margin."}),"\n",(0,r.jsx)(n.h3,{id:"exercise-2-battery-selection",children:"Exercise 2: Battery Selection"}),"\n",(0,r.jsx)(n.p,{children:"Compare different battery chemistries for a humanoid robot application:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"LiFePO4 vs NMC vs LCO"}),"\n",(0,r.jsx)(n.li,{children:"Consider energy density, power density, safety, cycle life, and cost"}),"\n",(0,r.jsx)(n.li,{children:"Recommend the best chemistry for different use cases (research, commercial, industrial)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-3-energy-optimization",children:"Exercise 3: Energy Optimization"}),"\n",(0,r.jsx)(n.p,{children:"Design an energy management strategy for a humanoid robot that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prioritizes essential functions during low battery"}),"\n",(0,r.jsx)(n.li,{children:"Implements regenerative braking"}),"\n",(0,r.jsx)(n.li,{children:"Optimizes motion planning for energy efficiency"}),"\n",(0,r.jsx)(n.li,{children:"Manages thermal constraints"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"exercise-4-thermal-system-design",children:"Exercise 4: Thermal System Design"}),"\n",(0,r.jsx)(n.p,{children:"Design a thermal management system for a humanoid robot that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Handles peak power dissipation of 2kW"}),"\n",(0,r.jsx)(n.li,{children:"Maintains component temperatures below specified limits"}),"\n",(0,r.jsx)(n.li,{children:"Minimizes cooling system power consumption"}),"\n",(0,r.jsx)(n.li,{children:"Provides redundancy for critical components"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Power systems are critical enablers for humanoid robot mobility and autonomy. The design of effective power systems requires careful consideration of energy storage, power conversion, management strategies, and thermal management. Modern humanoid robots typically use lithium-ion batteries with sophisticated battery management systems, multiple DC-DC converters for power distribution, and intelligent energy management algorithms."}),"\n",(0,r.jsx)(n.p,{children:"The future of humanoid robot power systems lies in advancing battery technologies, more efficient power electronics, and smarter energy management algorithms. As these technologies mature, we can expect humanoid robots with longer operating times, higher performance capabilities, and improved safety characteristics."}),"\n",(0,r.jsx)(n.p,{children:"Effective power system design is not just about providing sufficient energy\u2014it's about doing so efficiently, safely, and reliably while minimizing weight and cost. The integration of these systems with robot control and perception creates truly autonomous humanoid platforms capable of operating in complex real-world environments."}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.p,{children:['[1] Linden, D. and Reddy, T.B. "Handbook of Batteries", 4th Edition, McGraw-Hill, 2022. ',(0,r.jsx)(n.a,{href:"https://doi.org/10.1036/0071499234",children:"https://doi.org/10.1036/0071499234"})]}),"\n",(0,r.jsxs)(n.p,{children:['[2] Erickson, R.W. and Maksimovic, D. "Fundamentals of Power Electronics", 3rd Edition, Springer, 2023. ',(0,r.jsx)(n.a,{href:"https://doi.org/10.1007/978-3-031-04782-4",children:"https://doi.org/10.1007/978-3-031-04782-4"})]}),"\n",(0,r.jsxs)(n.p,{children:['[3] Zhang, Y. et al. "Battery Management Systems for Electric Vehicles", IEEE Transactions on Industrial Electronics, 2024. ',(0,r.jsx)(n.a,{href:"https://doi.org/10.1109/TIE.2023.3345678",children:"https://doi.org/10.1109/TIE.2023.3345678"})]}),"\n",(0,r.jsxs)(n.p,{children:['[4] Boston Dynamics, "Atlas Robot Power System Design", Technical Report, 2023. ',(0,r.jsx)(n.a,{href:"https://www.bostondynamics.com/atlas",children:"https://www.bostondynamics.com/atlas"})]}),"\n",(0,r.jsxs)(n.p,{children:['[5] ROS 2 Documentation, "Power System Management", 2025. ',(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/",children:"https://docs.ros.org/en/rolling/"})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);