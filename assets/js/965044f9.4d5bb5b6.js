"use strict";(globalThis.webpackChunkphysical_and_humanoid_robotics_book=globalThis.webpackChunkphysical_and_humanoid_robotics_book||[]).push([[78],{4353:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"physical-fundamentals/kinematics-dynamics","title":"Kinematics and Dynamics","description":"Mathematical foundations of robot motion and force analysis","source":"@site/docs/02-physical-fundamentals/01-kinematics-dynamics.mdx","sourceDirName":"02-physical-fundamentals","slug":"/physical-fundamentals/kinematics-dynamics","permalink":"/Robotics-Book/docs/physical-fundamentals/kinematics-dynamics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02-physical-fundamentals/01-kinematics-dynamics.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Kinematics and Dynamics","sidebar_label":"Kinematics & Dynamics","description":"Mathematical foundations of robot motion and force analysis","hide_table_of_contents":false},"sidebar":"bookSidebar","previous":{"title":"Book Overview","permalink":"/Robotics-Book/docs/introduction/book-overview"},"next":{"title":"Actuators and Motors","permalink":"/Robotics-Book/docs/physical-fundamentals/actuators-motors"}}');var a=i(4848),s=i(8453);const o={title:"Kinematics and Dynamics",sidebar_label:"Kinematics & Dynamics",description:"Mathematical foundations of robot motion and force analysis",hide_table_of_contents:!1},r="Kinematics and Dynamics",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Basic Concepts",id:"basic-concepts",level:3},{value:"Applications",id:"applications",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Mathematical Foundation",id:"mathematical-foundation",level:3},{value:"Solution Methods",id:"solution-methods",level:3},{value:"Robot Dynamics",id:"robot-dynamics",level:2},{value:"Newton-Euler Equations",id:"newton-euler-equations",level:3},{value:"Lagrangian Mechanics",id:"lagrangian-mechanics",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Robot Arm Control",id:"robot-arm-control",level:3},{value:"Simulation Integration",id:"simulation-integration",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Workspace Analysis",id:"workspace-analysis",level:3},{value:"Singularities",id:"singularities",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"kinematics-and-dynamics",children:"Kinematics and Dynamics"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Understand forward and inverse kinematics for robot manipulators"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Master dynamic equations for robot motion and force analysis"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Apply mathematical concepts to practical robot control problems"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Implement basic kinematic and dynamic calculations in code"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Kinematics and dynamics form the mathematical foundation of robotics, enabling us to understand, predict, and control robot motion. While these topics can seem abstract, they provide the essential tools for designing robots that move precisely and interact safely with their environment."}),"\n",(0,a.jsx)(e.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,a.jsx)(e.h3,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,a.jsx)(e.p,{children:"Forward kinematics determines the position and orientation of a robot's end-effector given joint angles:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\nclass RobotArm:\n    def __init__(self, link_lengths):\n        """Initialize 2-DOF planar robot arm"""\n        self.L1 = link_lengths[0]  # Length of first link\n        self.L2 = link_lengths[1]  # Length of second link\n        \n    def forward_kinematics(self, theta1, theta2):\n        """Calculate end-effector position from joint angles"""\n        # Position of first joint\n        x1 = self.L1 * np.cos(theta1)\n        y1 = self.L1 * np.sin(theta1)\n        \n        # Position of second joint relative to first\n        x2 = x1 + self.L2 * np.cos(theta1 + theta2)\n        y2 = y1 + self.L2 * np.sin(theta1 + theta2)\n        \n        return x2, y2\n    \n    def get_jacobian(self, theta1, theta2):\n        """Calculate Jacobian matrix for velocity analysis"""\n        J11 = -self.L1 * np.sin(theta1) - self.L2 * np.sin(theta1 + theta2)\n        J12 = -self.L2 * np.sin(theta1 + theta2)\n        J21 = self.L1 * np.cos(theta1) + self.L2 * np.cos(theta1 + theta2)\n        J22 = self.L2 * np.cos(theta1 + theta2)\n        \n        return np.array([[J11, J12], [J21, J22]])\n\n# Example usage\narm = RobotArm([1.0, 0.8])  # Link lengths in meters\nx, y = arm.forward_kinematics(np.pi/4, np.pi/6)  # 45\xb0 and 30\xb0\nprint(f"End-effector position: ({x:.3f}, {y:.3f}) meters")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"applications",children:"Applications"}),"\n",(0,a.jsx)(e.p,{children:"Forward kinematics is essential for:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robot Control"}),": Converting joint commands to desired positions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path Planning"}),": Calculating trajectories for smooth motion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visualization"}),": Displaying robot configuration in simulation"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,a.jsx)(e.h3,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,a.jsx)(e.p,{children:"Inverse kinematics solves for joint angles given desired end-effector position:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def inverse_kinematics_2dof(target_x, target_y, L1, L2):\n    """Solve inverse kinematics for 2-DOF planar arm"""\n    # Distance to target\n    distance = np.sqrt(target_x**2 + target_y**2)\n    \n    # Check if target is reachable\n    if distance > (L1 + L2):\n        raise ValueError("Target out of reach")\n    \n    # Use law of cosines to find angles\n    cos_theta2 = (target_x**2 + target_y**2 - L1**2 - L2**2) / (2 * L1 * L2)\n    \n    if abs(cos_theta2) > 1:\n        # No solution exists\n        return None, None\n    \n    theta2 = np.arccos(cos_theta2)\n    \n    # Calculate theta1 using geometric approach\n    k1 = L1 + L2 * np.cos(theta2)\n    k2 = L2 * np.sin(theta2)\n    theta1 = np.arctan2(target_y, target_x - k1) - np.arctan2(k2, 0)\n    \n    return theta1, theta2\n\n# Example: Find joint angles for target position\ntarget_x, target_y = 1.2, 0.8\ntheta1, theta2 = inverse_kinematics_2dof(target_x, target_y, 1.0, 0.8)\nif theta1 is not None:\n    print(f"Joint angles: \u03b8\u2081 = {np.degrees(theta1):.1f}\xb0, \u03b8\u2082 = {np.degrees(theta2):.1f}\xb0")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"solution-methods",children:"Solution Methods"}),"\n",(0,a.jsx)(e.p,{children:"Different approaches to solve inverse kinematics:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Analytical Solutions"}),": Closed-form equations for simple robots"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Numerical Methods"}),": Iterative approaches for complex systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimization"}),": Minimizing error functions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Machine Learning"}),": Neural networks for kinematic mapping"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"robot-dynamics",children:"Robot Dynamics"}),"\n",(0,a.jsx)(e.h3,{id:"newton-euler-equations",children:"Newton-Euler Equations"}),"\n",(0,a.jsx)(e.p,{children:"The fundamental equations governing robot motion:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class RobotDynamics:\n    def __init__(self, mass, inertia):\n        self.mass = mass  # Robot mass in kg\n        self.inertia = inertia  # Moment of inertia in kg\u22c5m\xb2\n        \n    def calculate_torque(self, angular_acceleration):\n        """Calculate required torque for angular acceleration"""\n        # \u03c4 = I\u22c5\u03b1 (torque = moment of inertia \xd7 angular acceleration)\n        return self.inertia * angular_acceleration\n    \n    def calculate_angular_acceleration(self, torque):\n        """Calculate angular acceleration from applied torque"""\n        # \u03b1 = \u03c4/I (angular acceleration = torque / moment of inertia)\n        return torque / self.inertia\n\n# Example: Dynamics of a rotating joint\ndynamics = RobotDynamics(mass=5.0, inertia=0.2)\ntorque = dynamics.calculate_torque(angular_acceleration=2.0)  # 2 rad/s\xb2\nprint(f"Required torque: {torque:.2f} N\u22c5m")\n'})}),"\n",(0,a.jsx)(e.h3,{id:"lagrangian-mechanics",children:"Lagrangian Mechanics"}),"\n",(0,a.jsx)(e.p,{children:"Advanced method for complex robot systems:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def lagrangian_equations(q, q_dot, L, K):\n    """Generate equations of motion using Lagrangian mechanics"""\n    # L = T - V (Kinetic - Potential energy)\n    # Equations: d/dt(\u2202L/\u2202q\u0307) - \u2202L/\u2202q = 0\n    \n    # For simplified 1-DOF system:\n    # M(q)q\u0308 + C(q,q\u0307)q\u0307 + Kq = 0\n    \n    # Where M is mass matrix, C is Coriolis matrix, K is stiffness matrix\n    pass  # Implementation would depend on specific system\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,a.jsx)(e.h3,{id:"robot-arm-control",children:"Robot Arm Control"}),"\n",(0,a.jsx)(e.p,{children:"Applying kinematics and dynamics to real robot control:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <cmath>\n\nclass RobotController {\nprivate:\n    std::vector<double> joint_angles;\n    std::vector<double> joint_velocities;\n    \npublic:\n    void updateKinematics() {\n        // Update end-effector position\n        double x = L1 * cos(joint_angles[0]) + L2 * cos(joint_angles[0] + joint_angles[1]);\n        double y = L1 * sin(joint_angles[0]) + L2 * sin(joint_angles[0] + joint_angles[1]);\n        \n        std::cout << "End-effector position: (" << x << ", " << y << ")" << std::endl;\n    }\n    \n    void updateDynamics(double torque) {\n        // Update joint velocities using dynamics\n        double angular_acceleration = torque / INERTIA;\n        joint_velocities[0] += angular_acceleration * TIME_STEP;\n        \n        // Integrate to get new positions\n        joint_angles[0] += joint_velocities[0] * TIME_STEP;\n        joint_angles[1] += joint_velocities[1] * TIME_STEP;\n    }\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"simulation-integration",children:"Simulation Integration"}),"\n",(0,a.jsx)(e.p,{children:"Testing kinematics and dynamics in simulation environments:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# ROS2 node for robot kinematics\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Point\n\nclass KinematicsNode(Node):\n    def __init__(self):\n        super().__init__('kinematics_node')\n        self.publisher = self.create_publisher(Point, 'end_effector_position')\n        \n    def calculate_position(self, joint_angles):\n        # Implement forward kinematics\n        x, y = self.forward_kinematics(joint_angles)\n        return Point(x=x, y=y)\n    \n    def timer_callback(self):\n        # Publish end-effector position\n        position = self.calculate_position(self.current_joint_angles)\n        self.publisher.publish(position)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = KinematicsNode()\n    rclpy.spin(node)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,a.jsx)(e.h3,{id:"workspace-analysis",children:"Workspace Analysis"}),"\n",(0,a.jsx)(e.p,{children:"Understanding robot capabilities and limitations:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"def calculate_workspace(link_lengths, joint_limits):\n    \"\"\"Calculate reachable workspace of robot arm\"\"\"\n    # Generate grid of points\n    workspace_points = []\n    \n    for theta1 in np.linspace(joint_limits[0][0], joint_limits[0][1], 100):\n        for theta2 in np.linspace(joint_limits[1][0], joint_limits[1][1], 100):\n            x, y = forward_kinematics(theta1, theta2, link_lengths)\n            workspace_points.append([x, y])\n    \n    return np.array(workspace_points)\n\n# Visualize workspace\nimport matplotlib.pyplot as plt\n\nworkspace = calculate_workspace([1.0, 0.8], [(-np.pi, np.pi), (-np.pi, np.pi)])\nplt.scatter(workspace_points[:, 0], workspace_points[:, 1], s=1)\nplt.title('Robot Arm Workspace')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.grid(True)\nplt.axis('equal')\nplt.show()\n"})}),"\n",(0,a.jsx)(e.h3,{id:"singularities",children:"Singularities"}),"\n",(0,a.jsx)(e.p,{children:"Identifying and handling special configurations:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def check_singularity(jacobian):\n    """Check if robot is in singular configuration"""\n    # Calculate determinant of Jacobian\n    det = np.linalg.det(jacobian)\n    \n    if abs(det) < SINGULARITY_THRESHOLD:\n        return True, det\n    return False, det\n\ndef handle_singularity(joint_angles):\n    """Modify joint angles to avoid singularity"""\n    # Add small perturbation to escape singularity\n    return joint_angles + SINGULARITY_AVOIDANCE * np.random.randn(len(joint_angles))\n'})}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Kinematics and dynamics provide the mathematical foundation for understanding robot motion:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Forward Kinematics"}),": Predicts end-effector position from joint angles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inverse Kinematics"}),": Calculates joint angles for desired positions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamics"}),": Analyzes forces and torques required for motion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Applications"}),": Essential for robot control, simulation, and design"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"These mathematical tools enable precise robot control and are fundamental to advanced robotics applications. Understanding both the theory and practical implementation prepares you for designing and controlling sophisticated robotic systems."}),"\n",(0,a.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(e.p,{children:['[1] Siciliano, B. and Khatib, O., "Springer Handbook of Robotics", ',(0,a.jsx)(e.em,{children:"Springer"}),", 2016. ",(0,a.jsx)(e.a,{href:"https://www.springer.com/gp/book/9783319038555",children:"https://www.springer.com/gp/book/9783319038555"})]}),"\n",(0,a.jsxs)(e.p,{children:['[2] Craig, J.J., "Introduction to Robotics: Mechanics and Control", ',(0,a.jsx)(e.em,{children:"Pearson"}),", 2022. ",(0,a.jsx)(e.a,{href:"https://www.pearson.com/en-us/subject-catalog/p/craig-introduction-to-robotics-mechanics-and-control-4th-edition/",children:"https://www.pearson.com/en-us/subject-catalog/p/craig-introduction-to-robotics-mechanics-and-control-4th-edition/"})]}),"\n",(0,a.jsxs)(e.p,{children:['[3] Spong, M.W. et al., "Robot Modeling and Control", ',(0,a.jsx)(e.em,{children:"Wiley"}),", 2020. ",(0,a.jsx)(e.a,{href:"https://www.wiley.com/en-us/Robot+Modeling+and+Control-p-9781119544774",children:"https://www.wiley.com/en-us/Robot+Modeling+and+Control-p-9781119544774"})]}),"\n",(0,a.jsxs)(e.p,{children:['[4] ROS 2 Documentation, "Robot State and Kinematics", 2025. ',(0,a.jsx)(e.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Intermediate/Robot-State-and-Kinematics/",children:"https://docs.ros.org/en/rolling/Tutorials/Intermediate/Robot-State-and-Kinematics/"})]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>r});var t=i(6540);const a={},s=t.createContext(a);function o(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);